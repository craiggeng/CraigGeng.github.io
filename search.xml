<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS实现元素水平垂直居中</title>
      <link href="/2023/06/24/css-20230624-1/"/>
      <url>/2023/06/24/css-20230624-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS实现元素水平垂直居中"><a href="#CSS实现元素水平垂直居中" class="headerlink" title="CSS实现元素水平垂直居中"></a>CSS实现元素水平垂直居中</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>已知元素宽高<ol><li>absolute + 负margin</li><li>absolute + margin auto</li><li>absolute + calc（50% - 1&#x2F;2 width | height）</li></ol></li><li>未知元素宽高<ol><li>父元素Flex justify-content align-items</li><li>父元素Grid 子元素 justify-self align-self</li><li>Absolute transform:translate(-50%,-50%)</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 居中 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Position详解</title>
      <link href="/2023/06/24/css-20230624/"/>
      <url>/2023/06/24/css-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="细说Position"><a href="#细说Position" class="headerlink" title="细说Position"></a>细说Position</h1><p>Position总共有五个取值，分别为static默认定位，absolute绝对定位，relative相对定位，fixed固定定位和sticky粘性定位。</p><h2 id="Static默认定位"><a href="#Static默认定位" class="headerlink" title="Static默认定位"></a>Static默认定位</h2><p>该元素使用正常布局，此时 top、right、bottom、left 属性无效。</p><h2 id="Absolute绝对定位"><a href="#Absolute绝对定位" class="headerlink" title="Absolute绝对定位"></a>Absolute绝对定位</h2><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html</p><p>absolute 定位使元素的位置与文档流无关，因此不占据空间。<em><strong>绝对定位后会脱离文档流</strong></em></p><p>absolute 定位的元素和其他元素重叠。</p><h2 id="Relative相对定位"><a href="#Relative相对定位" class="headerlink" title="Relative相对定位"></a>Relative相对定位</h2><p>relative 相对定位元素的定位是相对其正常位置。就是相对于原来的位置进行定位</p><p>设置relative属性但不设置top left right</p><h2 id="Fixed固定定位"><a href="#Fixed固定定位" class="headerlink" title="Fixed固定定位"></a>Fixed固定定位</h2><p>元素的位置相对于浏览器窗口是固定位置。</p><p>即使窗口是滚动的它也不会移动。</p><p>Fixed定位使元素的位置与文档流无关，因此不占据空间。</p><p>Fixed定位的元素和其他元素重叠。</p><h2 id="Sticky粘性定位"><a href="#Sticky粘性定位" class="headerlink" title="Sticky粘性定位"></a>Sticky粘性定位</h2><p>包含了 relative 与 fixed 这两种定位模式，但不是同时存在，需要一个触发条件，即边偏移 top &#x2F; right &#x2F; bottom &#x2F; left 的值达到后就会切换 fixed 方式，不同定位方式，就分别显示该方式的定位特征。</p><p>举例子就是广告。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Position属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/2023/06/24/js-20230624/"/>
      <url>/2023/06/24/js-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器中的事件循环（EventLoop）"><a href="#浏览器中的事件循环（EventLoop）" class="headerlink" title="浏览器中的事件循环（EventLoop）"></a>浏览器中的事件循环（EventLoop）</h1><h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以<strong>微任务队列要优先于宏任务队列</strong>。</p><p>微任务，是语言提供的，Promise.then，MutationObserver</p><p>宏任务，是宿主环境提供的，比如浏览器，script主代码块，setImmediate setTimeout，setInterval</p><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p>同步代码，微任务异步代码，宏任务异步代码。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端跨域问题</title>
      <link href="/2023/06/24/web-20230624/"/>
      <url>/2023/06/24/web-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊跨域问题"><a href="#聊聊跨域问题" class="headerlink" title="聊聊跨域问题"></a>聊聊跨域问题</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>跨域问题的产生源于浏览器的同源策略，浏览器要求网页只能够获取与自身来源同源的资源。同源代表着协议，域名与端口均要相同</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>跨域问题会导致以下三个问题：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取 </li><li>DOM 和 Js对象无法获得</li><li>AJAX 请求不能发送</li></ol><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ol><li><p>JSONP(JSON with Padding) 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数，并在script标签内设置一个回调执行函数</p><p>但是缺点明显：只能实现get一种请求。</p><p>服务端要设置Content-Type为application&#x2F;json，并获取callback参数值</p></li><li><p>跨域资源共享（CORS）</p><ul><li>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。Access-Control-Allow-Credentials，允许前端带认证cookie：启用此项后，上面的域名不能为’*’，必须指定具体的域名，否则浏览器会提示</li></ul></li><li><p>nginx代理跨域</p></li></ol><p><strong>nginx反向代理接口跨域</strong></p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><pre><code class="nginx">#proxy服务器server &#123;    listen       81;    server_name  www.domain1.com;    location / &#123;        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js_20230623</title>
      <link href="/2023/06/23/js-20230623/"/>
      <url>/2023/06/23/js-20230623/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-栈与堆、浅拷贝与深拷贝"><a href="#JS-栈与堆、浅拷贝与深拷贝" class="headerlink" title="JS 栈与堆、浅拷贝与深拷贝"></a>JS 栈与堆、浅拷贝与深拷贝</h1><h2 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h2><p><strong>栈内存</strong>：JS中的基础数据类型（固定大小）存放于栈内存中（Number，String，Boolean，Null，Undefined），访问时是按值访问。</p><p><strong>堆内存</strong>：JS中的引用数据类型（大小不固定）存放于堆内存中（Array，Object），访问时是按引用访问。访问保存在栈内存中的一个地址。地址与堆内存中的存储位置对应。变量存在于栈内存中，对象存在于堆内存中。</p><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>JS环境中分配的内存一般有如下生命周期：</p><ol><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</li></ol><h2 id="浅拷贝与深拷贝与赋值"><a href="#浅拷贝与深拷贝与赋值" class="headerlink" title="浅拷贝与深拷贝与赋值"></a>浅拷贝与深拷贝与赋值</h2><ol><li>赋值：赋值的是栈中的地址，不是堆中的数据。两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，基本数据类型互不影响，引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li></ol><p><img src="/../images/js_20230623_1.png" alt="js_20230623_1"></p><p><img src="/../images/js_20230623_2.png" alt="js_20230623_2"></p><h2 id="浅拷贝与深拷贝的实现方式"><a href="#浅拷贝与深拷贝的实现方式" class="headerlink" title="浅拷贝与深拷贝的实现方式"></a>浅拷贝与深拷贝的实现方式</h2><h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><ol><li>Object.assign()</li><li>lodash的 _.clone方法</li><li>ES6  …展开运算符</li></ol><h3 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h3><ol><li><p>JSON.parse(JSON.stringify())</p></li><li><p>lodash 的 _.deepclone方法</p></li><li><p>手写</p><pre><code class="javascript">function deepClone(obj, hash = new WeakMap()) &#123;    if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作    if (obj instanceof Date) return new Date(obj);    if (obj instanceof RegExp) return new RegExp(obj);    // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝    if (typeof obj !== &quot;object&quot;) return obj;    // 是对象的话就要进行深拷贝    if (hash.get(obj)) return hash.get(obj);    let cloneObj = new obj.constructor();    // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身    hash.set(obj, cloneObj);    for (let key in obj) &#123;        if (obj.hasOwnProperty(key)) &#123;          // 实现一个递归拷贝              cloneObj[key] = deepClone(obj[key], hash);        &#125;    &#125;    return cloneObj;&#125;</code></pre></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 栈与堆 </tag>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cybersecurity_20230623</title>
      <link href="/2023/06/23/cybersecurity-20230623/"/>
      <url>/2023/06/23/cybersecurity-20230623/</url>
      
        <content type="html"><![CDATA[<h1 id="常见网络安全问题及解决方案"><a href="#常见网络安全问题及解决方案" class="headerlink" title="常见网络安全问题及解决方案"></a>常见网络安全问题及解决方案</h1><h2 id="XSS攻击（跨站脚本攻击）"><a href="#XSS攻击（跨站脚本攻击）" class="headerlink" title="XSS攻击（跨站脚本攻击）"></a>XSS攻击（跨站脚本攻击）</h2><p>XSS是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全,任何可以输入的地方都有可能引起,包括表单、URL…</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>存储型XSS攻击<ol><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码<strong>提交到被攻击的网站的数据库中</strong>；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ol></li><li>反射型XSS攻击<ol><li><strong>攻击者构造出特殊的 URL</strong>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li>基于DOM的XSS攻击<ol><li>攻击者通过某种方式，将恶意脚本代码插入到网页中的某个元素中，比如一个输入框或者链接等。</li><li>受害者浏览器通过解析HTML代码生成文档对象模型（DOM）树，恶意脚本代码被加入到DOM树中。</li><li>当受害者与网页进行交互时，例如点击一个链接、提交表单等操作，浏览器就会执行恶意脚本代码。</li><li>恶意脚本代码可以执行一些攻击者预设好的操作，如窃取cookie信息、更改页面内容、将受害者重定向到恶意网站等。</li></ol></li></ul><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li>现代浏览器支持防御部分XSS攻击，在http设置X-XSS-Protection响应头，1为开启0为关闭，mode&#x3D;block意为如果检测到XSS攻击阻止整个界面</li><li>在Cookie和HTTP头中设置HTTP-Only和secure属性，以免被XSS攻击者获取</li><li>合理使用CSP（Content Security Policy）来限制第三方内容的注入，它分别可以使用HTTP请求、HTML mate表情的形式来开启</li></ol><h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>CSRF 攻击是攻击者利用浏览器在发起请求时自动带上 cookie 的特性，借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li>受害者登录 a.com，并保留了登录凭证（Cookie）；</li><li>攻击者引诱受害者访问了 b.com；</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx浏览器会默认携带a.com的Cookie；</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求；</li><li>a.com以受害者的名义执行了act&#x3D;xx；</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作；</li></ol><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><ol><li>ET型：如在页面的某个 img 中发起一个 get 请求</li><li>POST型：通过自动提交表单到恶意网站</li><li>链接型：需要诱导用户点击链接</li></ol><h3 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li><p>Cookie 的 SameSite 属性，对于现代浏览器，在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p><ul><li><p>Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</p></li><li><p>Lax 允许部分第三方请求携带 Cookie</p></li><li><p>None 无论是否跨站都会发送 Cookie</p></li></ul></li><li><p>同源检查，由服务器端验证当前请求的来源站点，HTTP 请求头中的 Referer 和 Origin 属性；</p></li><li><p>页面级别的token，将Token输出到页面中，页面提交的请求携带这个Token，服务器验证Token是否正确；</p></li><li><p>验证码，后端接口加验证码校验，让攻击方无法在用户无感知的情况下正常调用接口</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> XSS </tag>
            
            <tag> CRSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>== 与 ===</title>
      <link href="/2023/06/23/js-20230619/"/>
      <url>/2023/06/23/js-20230619/</url>
      
        <content type="html"><![CDATA[<!-- ---title: date: 2023-06-19 21:20:36tags: JavaScript Basic-Knowledge Interview--- --><h1 id="JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’"><a href="#JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’" class="headerlink" title="JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’"></a>JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>“&#x3D;&#x3D;“叫做相等运算符，”&#x3D;&#x3D;&#x3D;”叫做严格运算符</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>对于String, number这些基础类型，&#x3D;&#x3D;操作符会先把两边的变量进行类型强制转换成相同的类型再比较是否相等；&#x3D;&#x3D;&#x3D;操作符则不会进行类型转换，而是直接进行比较。</li><li>对于array, object这些高级类型，&#x3D;&#x3D;和 &#x3D;&#x3D;&#x3D;是没有区别的，因为它们比较的是 “指针地址” 。</li><li>对于基础类型和高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;是有区别的；&#x3D;&#x3D;操作符会先把高级类型转换为基础类型之后，进行<strong>值的比较</strong>；&#x3D;&#x3D;&#x3D;操作符则不会进行转换，<strong>类型比较</strong>，如果不同，直接返回false</li></ol><pre><code class="javascript">examle:    66 == &#39;66&#39; // True    66 === &#39;66&#39; // False</code></pre><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>对于特殊值NaN（Not a Number），表示非数字，NaN和任何数（包括它自己）做相等比较，都会返回false，所以判断NaN最好用isNaN()函数</li><li>null和undefined，两者值比较为True（&#x3D;&#x3D;），类型比较为False（&#x3D;&#x3D;&#x3D;）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay03</title>
      <link href="/2023/03/06/%E5%89%91%E6%8C%87offerDay03/"/>
      <url>/2023/03/06/%E5%89%91%E6%8C%87offerDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——字符串（简单）"><a href="#剑指offerDay02——字符串（简单）" class="headerlink" title="剑指offerDay02——字符串（简单）"></a>剑指offerDay02——字符串（简单）</h1><h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h2><p><img src="/../images/offer05.png" alt="offer05"></p><p>💡思路：</p><ul><li>新建一个StringBuilder，逐字符复制，遇到空格则用“%20”替代</li><li>原地修改更省内存</li></ul><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;        StringBuilder res = new StringBuilder();        for(Character c : s.toCharArray())        &#123;            if(c == &#39; &#39;) res.append(&quot;%20&quot;);            else res.append(c);        &#125;        return res.toString();    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay02</title>
      <link href="/2023/03/04/%E5%89%91%E6%8C%87offerDay02/"/>
      <url>/2023/03/04/%E5%89%91%E6%8C%87offerDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——链表（简单）"><a href="#剑指offerDay02——链表（简单）" class="headerlink" title="剑指offerDay02——链表（简单）"></a>剑指offerDay02——链表（简单）</h1><h2 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06 从尾到头打印链表"></a>剑指offer 06 从尾到头打印链表</h2><p><img src="/../images/offer06.png" alt="offer06"></p><p>💡思路：</p><ul><li>递归法，先递归到达链表尾部，再用push(head.val)将节点值添加进数组</li><li>循环法，JS可以用数组的unshift方法来从头插入数据，也可以用push + reverse 操作</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.unshift(head.val)        head = head.next    &#125;    return res&#125;;var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.push(head.val)        head = head.next    &#125;    return res.reverse()&#125;;var reversePrint = function (head) &#123;    if(!head) return []    let result = reversePrint(head.next)    result.push(head.val);    return result&#125;;</code></pre><h2 id="剑指offer24-反转链表"><a href="#剑指offer24-反转链表" class="headerlink" title="剑指offer24 反转链表"></a>剑指offer24 反转链表</h2><p><img src="/../images/offer24.png" alt="offer24"></p><p>💡思路：</p><ul><li>JS ES6中的解构语法，可以很好的进行赋值。</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123;    let [p,c] = [null, head]    while(c)&#123;        [c.next,c,p] = [p,c.next,c]    &#125;    return p&#125;;</code></pre><h2 id="剑指offer35-复杂链表的复制"><a href="#剑指offer35-复杂链表的复制" class="headerlink" title="剑指offer35 复杂链表的复制"></a>剑指offer35 复杂链表的复制</h2><p><img src="/../images/offer35_1.png" alt="offer35_1"></p><p><img src="/../images/offer35_2.png" alt="offer35_2"></p><p>💡思路：</p><ul><li>使用hash Map简历原节点 -&gt; 新节点的映射，先复制普通的val与next指针，后根据Map复制random指针<ol><li>复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</li><li>构建新链表的 next 和 random 指向</li><li>返回新链表的头节点</li></ol></li><li>也可先直接将新节点与旧节点连接至一个列表上，再进行新旧列表的拆分。<ol><li>复制各节点，并构建拼接链表</li><li>构建各新节点的 random 指向</li><li>拆分两链表</li></ol></li></ul><pre><code class="javascript">/** * // Definition for a Node. * function Node(val, next, random) &#123; *    this.val = val; *    this.next = next; *    this.random = random; * &#125;; *//** * @param &#123;Node&#125; head * @return &#123;Node&#125; */var copyRandomList = function(head) &#123;    if(head === null)&#123;        return head    &#125;    let curr = head    let newHead = new Node()    let newCurr = newHead    let map = new Map()    while(curr)&#123;        newCurr.val = curr.val        newCurr.next = curr.next ? new Node() : null                map.set(curr, newCurr)        newCurr = newCurr.next        curr = curr.next    &#125;    newCurr = newHead    while(head)&#123;        newCurr.random = head.random ? map.get(head.random) : null        head = head.next        newCurr = newCurr.next    &#125;    return newHead&#125;;// 拼接+拆分链表，空间复杂度O(1)var copyRandomList = function(head)&#123;    if(!head) return head;    let node = head;    // 复制节点，将新节点放到原节点后面    while(node)&#123;        node.next = new Node(node.val, node.next);        node = node.next.next;    &#125;    node = head;    // 构建新节点的random指向    while(node)&#123;        if(node.random !== null) node.next.random = node.random.next;        node = node.next.next;    &#125;    // 拆分链表    let newNode = head.next, res = newNode;    node = head;    while(node.next &amp;&amp; newNode.next)&#123;        node.next = node.next.next;        newNode.next = newNode.next.next;        node = node.next;        newNode = newNode.next;    &#125;    node.next= null;    // 返回新链表的头结点    return res;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay01</title>
      <link href="/2023/03/03/%E5%89%91%E6%8C%87offerDay01/"/>
      <url>/2023/03/03/%E5%89%91%E6%8C%87offerDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay01——栈与队列（简单）"><a href="#剑指offerDay01——栈与队列（简单）" class="headerlink" title="剑指offerDay01——栈与队列（简单）"></a>剑指offerDay01——栈与队列（简单）</h1><h2 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09 用两个栈实现队列"></a>剑指offer 09 用两个栈实现队列</h2><p><img src="/../images/offer09.png" alt="offer09"></p><p>💡<strong>思路</strong>：</p><ul><li>两个栈分别作用是<strong>入队栈</strong>、<strong>出队栈</strong></li><li><strong>appendTail</strong>方法直接在入队栈内push</li><li><strong>deleteHead</strong>方法需要检查两个栈的长度，先判断出队栈，再判断入队栈。<ol><li>均为空 -&gt; 队列为空</li><li>出队空，入队不空 -&gt; 先用out.push(in.pop)操作将入队栈的元素放入出队栈（两个栈的特性自然维护队列的特性），再pop出队栈.</li></ol></li></ul><pre><code class="javascript">var CQueue = function() &#123;    this.inStack = [];    this.outStack = [];&#125;;/**  * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123;    this.inStack.push(value);&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123;    if (!this.outStack.length) &#123;        if (!this.inStack.length) &#123;            return -1;        &#125;        this.in2out();    &#125;    return this.outStack.pop();&#125;;CQueue.prototype.in2out = function() &#123;    while (this.inStack.length) &#123;        this.outStack.push(this.inStack.pop());    &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */</code></pre><h2 id="剑指offer-30-包含min函数的栈"><a href="#剑指offer-30-包含min函数的栈" class="headerlink" title="剑指offer 30 包含min函数的栈"></a>剑指offer 30 包含min函数的栈</h2><p><img src="/../images/offer30.png" alt="offer30"></p><p>💡<strong>思路</strong>：</p><ul><li>设置辅助栈，原栈push时，min栈同时保存当前整个栈的min值，即push当前元素和min栈栈顶元素更小的那一个。</li><li>注意开始辅助栈，放入无穷大（Infinity）</li></ul><pre><code class="JavaScript">var MinStack = function() &#123;    this.x_stack = [];    this.min_stack = [Infinity];&#125;;MinStack.prototype.push = function(x) &#123;    this.x_stack.push(x);    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));&#125;;MinStack.prototype.pop = function() &#123;    this.x_stack.pop();    this.min_stack.pop();&#125;;MinStack.prototype.top = function() &#123;    return this.x_stack[this.x_stack.length - 1];&#125;;MinStack.prototype.min = function() &#123;    return this.min_stack[this.min_stack.length - 1];&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>你好Hexo<br>你好世界<br><a href="https://craiggeng.github.io/">我的Github个人网站</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/31/hello-world/"/>
      <url>/2022/08/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

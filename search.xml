<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>craigmessengerWeb实时聊天项目总结</title>
      <link href="/2023/07/02/craigmessengerWeb%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/02/craigmessengerWeb%E5%AE%9E%E6%97%B6%E8%81%8A%E5%A4%A9%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="CraigMessenger——Web实时聊天项目总结"><a href="#CraigMessenger——Web实时聊天项目总结" class="headerlink" title="CraigMessenger——Web实时聊天项目总结"></a>CraigMessenger——Web实时聊天项目总结</h1><h2 id="项目简述："><a href="#项目简述：" class="headerlink" title="项目简述："></a>项目简述：</h2><p>基于PusherJS库的Web端实时聊天项目</p><h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>React Next.js13 Next-Auth Cloudinary Pusher-js Prisma MongoDB</p><h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ol><li><p><strong>登陆</strong> </p><p>使用Next-Auth验证，普通账号密码，社交媒体Github以及Google登陆</p></li><li><p>实时聊天</p><p>整体的实时通信都是用Pusher来实现的，pusher底层是基于WebSocket来实现的。</p><p>他提供了基于事件的API接口，并且易于查询频道情况，在线用户等常用信息。并且提供了端到端的信息加密，保证了</p><p>在使用前要现在官网注册账号并申请APPid。</p><p>在使用时进行配置在服务端进行配置</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CraigMessenger </tag>
            
            <tag> Web端IM聊天 </tag>
            
            <tag> PusherJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>craigbnb民宿预定项目总结</title>
      <link href="/2023/07/02/craigbnb%E6%B0%91%E5%AE%BF%E9%A2%84%E5%AE%9A%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
      <url>/2023/07/02/craigbnb%E6%B0%91%E5%AE%BF%E9%A2%84%E5%AE%9A%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode739_每日温度</title>
      <link href="/2023/07/01/Leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/"/>
      <url>/2023/07/01/Leetcode739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode739-每日温度"><a href="#Leetcode739-每日温度" class="headerlink" title="Leetcode739.每日温度"></a>Leetcode739.每日温度</h1><h2 id="❓问题"><a href="#❓问题" class="headerlink" title="❓问题"></a>❓问题</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><h2 id="💡解答"><a href="#💡解答" class="headerlink" title="💡解答"></a>💡解答</h2><p>最简单方法：暴力循环 O（n2）</p><p>改进方法：<strong>单调栈</strong></p><p>明确以下几点：</p><ol><li>单调栈里存放的元素是什么？</li></ol><p>​——单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p><ol start="2"><li>单调栈里元素是递增呢？ 还是递减呢？</li></ol><p>​——<strong>顺序的描述为 从栈头到栈底的顺序</strong>，采用递增排序</p><pre><code class="javascript">var dailyTemperatures = function(temperatures) &#123;    const n = temperatures.length;    const res = Array(n).fill(0);    const stack = [];  // 递增栈：用于存储元素右面第一个比他大的元素下标    stack.push(0);    for (let i = 1; i &lt; n; i++) &#123;        while (stack.length &amp;&amp; temperatures[i] &gt; temperatures[stack[stack.length - 1]]) &#123;            const top = stack.pop();            res[top] = i - top;        &#125;        stack.push(i);    &#125;    return res;&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode198_打家劫舍</title>
      <link href="/2023/07/01/Leetcode198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/"/>
      <url>/2023/07/01/Leetcode198-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Leetcode198-打家劫舍"><a href="#Leetcode198-打家劫舍" class="headerlink" title="Leetcode198. 打家劫舍"></a>Leetcode198. 打家劫舍</h1><h2 id="❓问题"><a href="#❓问题" class="headerlink" title="❓问题"></a>❓问题</h2><p>请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><p>例如，给定一个列表 temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</p><p>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</p><h2 id="💡解答"><a href="#💡解答" class="headerlink" title="💡解答"></a>💡解答</h2><h5 id="动态规划五部曲："><a href="#动态规划五部曲：" class="headerlink" title="动态规划五部曲："></a>动态规划五部曲：</h5><ol><li><p>确定dp数组以及下标的含义</p></li><li><p>确定递推公式</p></li><li><p>dp数组如何初始化</p></li><li><p>确定遍历顺序</p></li><li><p>举例推导dp数组</p></li><li><p>确定dp数组（dp table）以及下标的含义</p></li></ol><p>**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。</p><ol start="2"><li>确定递推公式</li></ol><p>决定dp[i]的因素就是第i房间偷还是不偷。</p><p>如果偷第i房间，那么dp[i] &#x3D; dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。</p><p>如果不偷第i房间，那么dp[i] &#x3D; dp[i - 1]，即考 虑i-1房，（<strong>注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点</strong>）</p><p>然后dp[i]取最大值，即dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);</p><ol start="3"><li>dp数组如何初始化</li></ol><p>从递推公式dp[i] &#x3D; max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]</p><p>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] &#x3D; max(nums[0], nums[1]);</p><p>代码如下：</p><pre><code class="javascript">// 数组长度const len = nums.length;// dp数组初始化const dp = [nums[0], Math.max(nums[0], nums[1])];</code></pre><ol start="4"><li>确定遍历顺序</li></ol><p>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</p><p>代码如下：</p><pre><code class="javascript">for (int i = 2; i &lt; nums.size(); i++) &#123;    dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);&#125;</code></pre><ol start="5"><li>举例推导dp数组</li></ol><p>以示例二，输入[2,7,9,3,1]为例。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210221170954115.jpg" alt="198.打家劫舍"></p><p>红框dp[nums.size() - 1]为结果。</p><p>代码：</p><pre><code class="javascript">const rob = nums =&gt; &#123;    // 数组长度    const len = nums.length;    // dp数组初始化    const dp = [nums[0], Math.max(nums[0], nums[1])];    // 从下标2开始遍历    for (let i = 2; i &lt; len; i++) &#123;        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);    &#125;    return dp[len - 1];&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器的缓存机制</title>
      <link href="/2023/06/25/web-20230625/"/>
      <url>/2023/06/25/web-20230625/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h1><p><img src="/../images/web_20230625.png" alt="web_20230625"></p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p><p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>Expires是HTTP&#x2F;1.0控制网页缓存的字段，其值为服务器返回该请求结果<code>缓存的到期时间</code>，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag &#x2F; If-None-Match的优先级比Last-Modified &#x2F; If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果</li></ol><h5 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h5><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，</p><h5 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag &#x2F; If-None-Match"></a>Etag &#x2F; If-None-Match</h5><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p>通常服务器生成并返回在Etag中的验证码，常常是文件内容的哈希值或者某个其他指纹码。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其发送给服务器(浏览器默认会添加)：如果指纹码仍然一致，说明资源未被修改，服务器会返回304 Not Modified，这样我们就可以跳过下载，利用已经缓存了的资源，并且该资源会继续缓存120s。</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 缓存机制 </tag>
            
            <tag> 强制缓存 </tag>
            
            <tag> 协商缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流与防抖</title>
      <link href="/2023/06/24/js-20230624-2/"/>
      <url>/2023/06/24/js-20230624-2/</url>
      
        <content type="html"><![CDATA[<h1 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a>节流与防抖</h1><p><strong>函数防抖（debounce）</strong> <strong>函数节流（throttle）</strong> 都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟或卡顿的现象。</p><h2 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h2><p><strong>防抖：</strong> 触发高频事件，n秒后，函数会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。</p><p><strong>应用场景：</strong></p><ul><li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li><li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li><li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li></ul><p>如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会执行handle函数。</p><p><img src="/../images/js_20230624_1.png" alt="js_20230624_1"></p><pre><code class="javascript">function debounce(fn, delay)&#123;    let timer = null    return function() &#123;        if(timer) clearTimeout(timer)             timer = setTimeout(() =&gt; &#123;            fn.apply(this, arguments);            timer = null        &#125;, delay)    &#125;&#125;</code></pre><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p><strong>节流：</strong>高频事件触发，但在n秒内只会执行一次真正的事件处理函数，所以节流会稀释函数的执行频率。原理是通过判断是否有延迟调用函数未执行。</p><p><strong>应用场景</strong>：</p><ul><li>鼠标连续不断地触发某事件（如点击），单位时间内只触发一次；</li><li>监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断。例如：懒加载；</li><li>浏览器播放事件，每个一秒计算一次进度信息等</li></ul><p>如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p><p><img src="/../images/js_20230624_2.png" alt="js_20230624_2"></p><pre><code class="javascript">function throttle(fn, delay)&#123;  let timer = null  return function()&#123;    if(timer) return    timer = setTimeout(()=&gt;&#123;      fn.apply(this, arguments)      timer = null    &#125;,delay)  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性解析</title>
      <link href="/2023/06/24/js-20230624-1/"/>
      <url>/2023/06/24/js-20230624-1/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6新特性解析"><a href="#ES6新特性解析" class="headerlink" title="ES6新特性解析"></a>ES6新特性解析</h1><h2 id="ES6语法中箭头函数-x3D-gt-与function的区别？"><a href="#ES6语法中箭头函数-x3D-gt-与function的区别？" class="headerlink" title="ES6语法中箭头函数()&#x3D;&gt;{} 与function的区别？"></a>ES6语法中箭头函数()&#x3D;&gt;{} 与function的区别？</h2><ol><li><strong>this的指向</strong>：使用<strong>function</strong>定义的函数，this的指向随着调用环境的变化而<strong>变化的</strong>，而<strong>箭头函数</strong>中的this指向是<strong>固定不变的</strong>，永远指向它定义时的上层作用域中的this，即一直指向的是定义函数的环境</li><li><strong>构造函数</strong>：function是可以定义构造函数的，而箭头函数是不行的。</li><li><strong>变量提升</strong>：由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升。<strong>故箭头函数一定要定义于调用之前！</strong>（function不用）</li><li>箭头函数只能声明<strong>匿名函数</strong>可通过表达式让函数具名，function既可以声明匿名也可由声明具名函数</li></ol><h2 id="var、let、const的区别？"><a href="#var、let、const的区别？" class="headerlink" title="var、let、const的区别？"></a>var、let、const的区别？</h2><ol><li><p><strong>作用域</strong>：<strong>let</strong>和<strong>const</strong>具有块级作用域，<strong>var</strong>不存在块级作用域,可以跨块访问, 不能跨函数访问。<strong>var出来的变量是全局的，但是不能跨函数访问</strong></p></li><li><p><strong>变量提升</strong>：什么是变量提升？变量能在声明之前使用，就是变量提升。<strong>var存在变量提升，let和const不存在变量提升</strong> var在js中是支持预解析的声明出来的就不会报错是undefined，let，const就会报错</p></li><li><p><strong>全局属性</strong>：浏览器的全局对象是window。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性（window.a 可以访问到），但是let和const不会</p></li><li><p><strong>重复声明</strong>：let const不可重复声明，var可以只会记录最后一个值。</p></li><li><p><strong>暂时性死区</strong>：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区</p></li><li><p><strong>初始值</strong>：<strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</strong></p></li><li><p><strong>指针指向</strong>：let和const都是ES6新语法， let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p></li><li><p><strong>应用场景</strong>：</p><p>块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>应用场景：以后声明变量使用 let 就对了</strong></p><p><strong>应用场景：声明对象类型使用 const，非对象类型声明选择 let</strong></p><p><strong>没有特殊情况就不要用var了</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> const, </tag>
            
            <tag> var </tag>
            
            <tag> let </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> function函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现元素水平垂直居中</title>
      <link href="/2023/06/24/css-20230624-1/"/>
      <url>/2023/06/24/css-20230624-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS实现元素水平垂直居中"><a href="#CSS实现元素水平垂直居中" class="headerlink" title="CSS实现元素水平垂直居中"></a>CSS实现元素水平垂直居中</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>已知元素宽高<ul><li>父元素相对定位</li><li>absolute + 负margin</li><li>absolute + margin auto</li><li>absolute + calc（50% - 1&#x2F;2 width | height）</li></ul></li><li>未知元素宽高<ol><li>父元素Flex justify-content align-items</li><li>父元素Grid 子元素 justify-self align-self</li><li>Absolute transform:translate(-50%,-50%)</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> CSS </tag>
            
            <tag> 居中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Position详解</title>
      <link href="/2023/06/24/css-20230624/"/>
      <url>/2023/06/24/css-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="细说Position"><a href="#细说Position" class="headerlink" title="细说Position"></a>细说Position</h1><p>Position总共有五个取值，分别为static默认定位，absolute绝对定位，relative相对定位，fixed固定定位和sticky粘性定位。</p><h2 id="Static默认定位"><a href="#Static默认定位" class="headerlink" title="Static默认定位"></a>Static默认定位</h2><p>该元素使用正常布局，此时 top、right、bottom、left 属性无效。</p><h2 id="Absolute绝对定位"><a href="#Absolute绝对定位" class="headerlink" title="Absolute绝对定位"></a>Absolute绝对定位</h2><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html</p><p>absolute 定位使元素的位置与文档流无关，因此不占据空间。<em><strong>绝对定位后会脱离文档流</strong></em></p><p>absolute 定位的元素和其他元素重叠。</p><h2 id="Relative相对定位"><a href="#Relative相对定位" class="headerlink" title="Relative相对定位"></a>Relative相对定位</h2><p>relative 相对定位元素的定位是相对其正常位置。就是相对于原来的位置进行定位</p><p>设置relative属性但不设置top left right</p><h2 id="Fixed固定定位"><a href="#Fixed固定定位" class="headerlink" title="Fixed固定定位"></a>Fixed固定定位</h2><p>元素的位置相对于浏览器窗口是固定位置。</p><p>即使窗口是滚动的它也不会移动。</p><p>Fixed定位使元素的位置与文档流无关，因此不占据空间。</p><p>Fixed定位的元素和其他元素重叠。</p><h2 id="Sticky粘性定位"><a href="#Sticky粘性定位" class="headerlink" title="Sticky粘性定位"></a>Sticky粘性定位</h2><p>包含了 relative 与 fixed 这两种定位模式，但不是同时存在，需要一个触发条件，即边偏移 top &#x2F; right &#x2F; bottom &#x2F; left 的值达到后就会切换 fixed 方式，不同定位方式，就分别显示该方式的定位特征。</p><p>举例子就是广告。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Position属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/2023/06/24/js-20230624/"/>
      <url>/2023/06/24/js-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器中的事件循环（EventLoop）"><a href="#浏览器中的事件循环（EventLoop）" class="headerlink" title="浏览器中的事件循环（EventLoop）"></a>浏览器中的事件循环（EventLoop）</h1><h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以<strong>微任务队列要优先于宏任务队列</strong>。</p><p>微任务，是语言提供的，Promise.then，MutationObserver</p><p>宏任务，是宿主环境提供的，比如浏览器，script主代码块，setImmediate setTimeout，setInterval</p><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p>同步代码，微任务异步代码，宏任务异步代码。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端跨域问题</title>
      <link href="/2023/06/24/web-20230624/"/>
      <url>/2023/06/24/web-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊跨域问题"><a href="#聊聊跨域问题" class="headerlink" title="聊聊跨域问题"></a>聊聊跨域问题</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>跨域问题的产生源于浏览器的同源策略，浏览器要求网页只能够获取与自身来源同源的资源。同源代表着协议，域名与端口均要相同</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>跨域问题会导致以下三个问题：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取 </li><li>DOM 和 Js对象无法获得</li><li>AJAX 请求不能发送</li></ol><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ol><li><p>JSONP(JSON with Padding) 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数，并在script标签内设置一个回调执行函数</p><p>但是缺点明显：只能实现get一种请求。</p><p>服务端要设置Content-Type为application&#x2F;json，并获取callback参数值</p></li><li><p>跨域资源共享（CORS）</p><ul><li>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。Access-Control-Allow-Credentials，允许前端带认证cookie：启用此项后，上面的域名不能为’*’，必须指定具体的域名，否则浏览器会提示</li></ul></li><li><p>nginx代理跨域</p></li></ol><p><strong>nginx反向代理接口跨域</strong></p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><pre><code class="nginx">#proxy服务器server &#123;    listen       81;    server_name  www.domain1.com;    location / &#123;        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 栈与堆、浅拷贝与深拷贝</title>
      <link href="/2023/06/23/js-20230623/"/>
      <url>/2023/06/23/js-20230623/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-栈与堆、浅拷贝与深拷贝"><a href="#JS-栈与堆、浅拷贝与深拷贝" class="headerlink" title="JS 栈与堆、浅拷贝与深拷贝"></a>JS 栈与堆、浅拷贝与深拷贝</h1><h2 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h2><p><strong>栈内存</strong>：JS中的基础数据类型（固定大小）存放于栈内存中（Number，String，Boolean，Null，Undefined），访问时是按值访问。</p><p><strong>堆内存</strong>：JS中的引用数据类型（大小不固定）存放于堆内存中（Array，Object），访问时是按引用访问。访问保存在栈内存中的一个地址。地址与堆内存中的存储位置对应。变量存在于栈内存中，对象存在于堆内存中。</p><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>JS环境中分配的内存一般有如下生命周期：</p><ol><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</li></ol><h2 id="浅拷贝与深拷贝与赋值"><a href="#浅拷贝与深拷贝与赋值" class="headerlink" title="浅拷贝与深拷贝与赋值"></a>浅拷贝与深拷贝与赋值</h2><ol><li>赋值：赋值的是栈中的地址，不是堆中的数据。两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，基本数据类型互不影响，引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li></ol><p><img src="/../images/js_20230623_1.png" alt="js_20230623_1"></p><p><img src="/../images/js_20230623_2.png" alt="js_20230623_2"></p><h2 id="浅拷贝与深拷贝的实现方式"><a href="#浅拷贝与深拷贝的实现方式" class="headerlink" title="浅拷贝与深拷贝的实现方式"></a>浅拷贝与深拷贝的实现方式</h2><h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><ol><li>Object.assign()</li><li>lodash的 _.clone方法</li><li>ES6  …展开运算符</li></ol><h3 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h3><ol><li><p>JSON.parse(JSON.stringify())</p></li><li><p>lodash 的 _.deepclone方法</p></li><li><p>手写</p><pre><code class="javascript">function deepClone(obj, hash = new WeakMap()) &#123;    if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作    if (obj instanceof Date) return new Date(obj);    if (obj instanceof RegExp) return new RegExp(obj);    // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝    if (typeof obj !== &quot;object&quot;) return obj;    // 是对象的话就要进行深拷贝    if (hash.get(obj)) return hash.get(obj);    let cloneObj = new obj.constructor();    // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身    hash.set(obj, cloneObj);    for (let key in obj) &#123;        if (obj.hasOwnProperty(key)) &#123;          // 实现一个递归拷贝              cloneObj[key] = deepClone(obj[key], hash);        &#125;    &#125;    return cloneObj;&#125;</code></pre></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 栈与堆 </tag>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见网络安全问题及解决方案</title>
      <link href="/2023/06/23/cybersecurity-20230623/"/>
      <url>/2023/06/23/cybersecurity-20230623/</url>
      
        <content type="html"><![CDATA[<h1 id="常见网络安全问题及解决方案"><a href="#常见网络安全问题及解决方案" class="headerlink" title="常见网络安全问题及解决方案"></a>常见网络安全问题及解决方案</h1><h2 id="XSS攻击（跨站脚本攻击）"><a href="#XSS攻击（跨站脚本攻击）" class="headerlink" title="XSS攻击（跨站脚本攻击）"></a>XSS攻击（跨站脚本攻击）</h2><p>XSS是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全,任何可以输入的地方都有可能引起,包括表单、URL…</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>存储型XSS攻击<ol><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码<strong>提交到被攻击的网站的数据库中</strong>；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ol></li><li>反射型XSS攻击<ol><li><strong>攻击者构造出特殊的 URL</strong>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li>基于DOM的XSS攻击<ol><li>攻击者通过某种方式，将恶意脚本代码插入到网页中的某个元素中，比如一个输入框或者链接等。</li><li>受害者浏览器通过解析HTML代码生成文档对象模型（DOM）树，恶意脚本代码被加入到DOM树中。</li><li>当受害者与网页进行交互时，例如点击一个链接、提交表单等操作，浏览器就会执行恶意脚本代码。</li><li>恶意脚本代码可以执行一些攻击者预设好的操作，如窃取cookie信息、更改页面内容、将受害者重定向到恶意网站等。</li></ol></li></ul><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li>现代浏览器支持防御部分XSS攻击，在http设置X-XSS-Protection响应头，1为开启0为关闭，mode&#x3D;block意为如果检测到XSS攻击阻止整个界面</li><li>在Cookie和HTTP头中设置HTTP-Only和secure属性，以免被XSS攻击者获取</li><li>合理使用CSP（Content Security Policy）来限制第三方内容的注入，它分别可以使用HTTP请求、HTML mate表情的形式来开启</li></ol><h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>CSRF 攻击是攻击者利用浏览器在发起请求时自动带上 cookie 的特性，借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li>受害者登录 a.com，并保留了登录凭证（Cookie）；</li><li>攻击者引诱受害者访问了 b.com；</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx浏览器会默认携带a.com的Cookie；</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求；</li><li>a.com以受害者的名义执行了act&#x3D;xx；</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作；</li></ol><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><ol><li>ET型：如在页面的某个 img 中发起一个 get 请求</li><li>POST型：通过自动提交表单到恶意网站</li><li>链接型：需要诱导用户点击链接</li></ol><h3 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li><p>Cookie 的 SameSite 属性，对于现代浏览器，在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p><ul><li><p>Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</p></li><li><p>Lax 允许部分第三方请求携带 Cookie</p></li><li><p>None 无论是否跨站都会发送 Cookie</p></li></ul></li><li><p>同源检查，由服务器端验证当前请求的来源站点，HTTP 请求头中的 Referer 和 Origin 属性；</p></li><li><p>页面级别的token，将Token输出到页面中，页面提交的请求携带这个Token，服务器验证Token是否正确；</p></li><li><p>验证码，后端接口加验证码校验，让攻击方无法在用户无感知的情况下正常调用接口</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> XSS </tag>
            
            <tag> CRSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>== 与 ===</title>
      <link href="/2023/06/23/js-20230619/"/>
      <url>/2023/06/23/js-20230619/</url>
      
        <content type="html"><![CDATA[<!-- ---title: date: 2023-06-19 21:20:36tags: JavaScript Basic-Knowledge Interview--- --><h1 id="JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’"><a href="#JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’" class="headerlink" title="JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’"></a>JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>“&#x3D;&#x3D;“叫做相等运算符，”&#x3D;&#x3D;&#x3D;”叫做严格运算符</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>对于String, number这些基础类型，&#x3D;&#x3D;操作符会先把两边的变量进行类型强制转换成相同的类型再比较是否相等；&#x3D;&#x3D;&#x3D;操作符则不会进行类型转换，而是直接进行比较。</li><li>对于array, object这些高级类型，&#x3D;&#x3D;和 &#x3D;&#x3D;&#x3D;是没有区别的，因为它们比较的是 “指针地址” 。</li><li>对于基础类型和高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;是有区别的；&#x3D;&#x3D;操作符会先把高级类型转换为基础类型之后，进行<strong>值的比较</strong>；&#x3D;&#x3D;&#x3D;操作符则不会进行转换，<strong>类型比较</strong>，如果不同，直接返回false</li></ol><pre><code class="javascript">examle:    66 == &#39;66&#39; // True    66 === &#39;66&#39; // False</code></pre><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>对于特殊值NaN（Not a Number），表示非数字，NaN和任何数（包括它自己）做相等比较，都会返回false，所以判断NaN最好用isNaN()函数</li><li>null和undefined，两者值比较为True（&#x3D;&#x3D;），类型比较为False（&#x3D;&#x3D;&#x3D;）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/15/Note_Web&amp;Browser/"/>
      <url>/2023/06/15/Note_Web&amp;Browser/</url>
      
        <content type="html"><![CDATA[<h1 id="网络与浏览器"><a href="#网络与浏览器" class="headerlink" title="网络与浏览器"></a>网络与浏览器</h1><h2 id="1-浏览器在输入网址到显示网页的过程"><a href="#1-浏览器在输入网址到显示网页的过程" class="headerlink" title="1.浏览器在输入网址到显示网页的过程"></a>1.浏览器在输入网址到显示网页的过程</h2><ol><li>用户输入网址：用户在浏览器的地址栏中输入网址，例如：”<a href="http://www.example.com"./">www.example.com"。</a></li><li>DNS解析：浏览器会检查本地缓存中是否有与该网址对应的IP地址，如果没有，则会发送DNS（Domain Name System）请求到本地DNS服务器，以获取网址对应的IP地址。如果本地DNS服务器没有该记录，它会向其他DNS服务器发送请求，直到找到对应的IP地址。</li><li>建立连接：浏览器使用获取到的IP地址，通过TCP&#x2F;IP协议与服务器建立连接。这个过程通常涉及与服务器的三次握手，确保浏览器和服务器之间建立可靠的连接。</li><li>发送HTTP请求：一旦与服务器建立连接，浏览器会发送一个HTTP请求，其中包含了请求的类型（GET、POST等）、网址、以及其他附加信息，例如浏览器的信息、Cookie等。</li><li>服务器处理请求：服务器接收到浏览器发送的请求后，会根据请求的内容进行相应的处理。这可能包括读取请求中的数据、执行相应的代码、查询数据库等。</li><li>服务器发送响应：服务器处理完请求后，会生成一个HTTP响应，其中包含了所请求的网页内容以及其他相关信息。响应中的内容通常是一个HTML文档，但也可能包含其他资源，例如CSS样式表、JavaScript脚本、图像等。</li><li>接收响应：浏览器接收到服务器发送的响应后，会开始处理响应。如果响应中包含了其他资源的引用（例如CSS和JavaScript文件），浏览器会继续发送请求来获取这些资源。</li><li>渲染页面：浏览器使用接收到的HTML文档和其他资源，开始解析和渲染页面。它会解析HTML结构，构建DOM（Document Object Model）树，并根据CSS样式对页面进行布局和渲染。如果页面中包含JavaScript代码，浏览器还会执行这些代码。</li><li>显示页面：最后，浏览器会将渲染好的页面显示给用户。它会将页面的内容呈现在浏览器窗口中，并处理用户与页面的交互，例如点击链接、填写表单等</li></ol><h2 id="2-TCP三次握手"><a href="#2-TCP三次握手" class="headerlink" title="2.TCP三次握手"></a>2.TCP三次握手</h2><p>TCP三次握手是建立TCP连接时使用的一种协议，用于确保客户端和服务器之间建立可靠的连接。以下是TCP三次握手的步骤：</p><ol><li>第一次握手（SYN）：<ul><li>客户端发送一个带有SYN（同步序列编号）标志的TCP包给服务器。</li><li>这表示客户端请求与服务器建立连接，并指定一个初始的序列号（用于数据传输的顺序标记）。</li></ul></li><li>第二次握手（SYN-ACK）：<ul><li>服务器接收到客户端的请求后，会发送一个带有SYN和ACK（确认序列编号）标志的TCP包给客户端，ACK表示确认客户端的SYN，SYN也发送自己的初始序列号。</li><li>这表示服务器同意建立连接，并确认客户端的序列号，并指定自己的初始序列号。</li></ul></li><li>第三次握手（ACK）：<ul><li>客户端接收到服务器的响应后，会发送一个带有ACK标志的TCP包给服务器。</li><li>这表示客户端确认服务器的序列号，并且连接已经建立。</li><li>从此时开始，客户端和服务器可以开始进行数据传输。</li></ul></li></ol><p>通过这个三次握手的过程，客户端和服务器能够确保彼此都收到了对方的请求和确认，并且双方都知道了对方的初始序列号。这种握手过程可以防止连接建立失败或者无效连接的情况发生，并提供了一定的可靠性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Note_Interview</title>
      <link href="/2023/03/20/Note-Interview/"/>
      <url>/2023/03/20/Note-Interview/</url>
      
        <content type="html"><![CDATA[<h1 id="面试问题准备"><a href="#面试问题准备" class="headerlink" title="面试问题准备"></a>面试问题准备</h1><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="采用scss使得对css开发更灵活"><a href="#采用scss使得对css开发更灵活" class="headerlink" title="采用scss使得对css开发更灵活"></a>采用scss使得对css开发更灵活</h3><p>设置变量$ xxx, 统一UI风格，减少冗余代码。</p><h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><h3 id="怎么理解Typescript"><a href="#怎么理解Typescript" class="headerlink" title="怎么理解Typescript"></a>怎么理解Typescript</h3><p>Typescript是JavaScript + TypeSystem，是JS的一个超集。TypeScript的</p><p>JavaScript是一个动态类型语言，程序运行期间才做数据类型检查的语言。TypeScript是一个静态类型语言程序编译期间做数据类型检查的语言</p><ul><li>TypeScript 核心：解决 JavaScript 编程中的类型安全问题</li><li>配合IDE、编辑器提供更强大的代码智能提示&#x2F;检查</li><li>可以帮助我们更好地编写代码。代码即文档</li><li>程序编译阶段（配合IDE、编辑器甚至可以在编码阶段）即可发现一些潜在错误，避免程序在生产<br>环境运行了以后再出现错误；</li><li>编码规范、有利于团队开发协作、也更有利于大型项目开发、项目重构</li><li>缺点是麻烦且缺少灵活性</li></ul><h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><ul><li>五大核心概念：<ol><li>Entry 入口从哪个文件开始打包</li><li>Output 输出到哪里，如何命名</li><li>Loader webpack本身只能处理js和json，其他资源需要loader来处理</li><li>Plugin通过插件扩展webpack功能</li><li>Mode 模式开发和生产 Development 和 Production</li></ol></li><li>Loader与plugin的区别<ol><li>Loader用于对源代码文件进行转换和处理，Plugin用于对Webpack的编译过程进行扩展和增强。</li><li>Loader用于转换特定类型的文件，例如css，babel，图片等</li><li>loader运行在打包文件之前（loader为在模块加载时的预处理文件）；plugins在整个编译周期都起作用</li></ol></li></ul><h3 id="Webpack与Vite"><a href="#Webpack与Vite" class="headerlink" title="Webpack与Vite"></a>Webpack与Vite</h3><p><strong>Webpack</strong> 是一个基于打包器的构建工具，同一个入口文件的代码会打包成一个 Bundle 文件。Webpack 长期来的一个痛点是对于大规模应用的应用启动和热更新速度很慢。当文件发生变动时，bundle会被重新构建</p><h3 id="项目打包优化"><a href="#项目打包优化" class="headerlink" title="项目打包优化"></a>项目打包优化</h3><h5 id="Terser-webpack-plugin"><a href="#Terser-webpack-plugin" class="headerlink" title="Terser-webpack-plugin"></a>Terser-webpack-plugin</h5><p>用来去除生产环境中的<code>console</code>以及<code>debugger</code>等信息。</p><h3 id="Git面试题"><a href="#Git面试题" class="headerlink" title="Git面试题"></a>Git面试题</h3><h5 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h5><p>查看分支：git branch 提交git commit<br>创建分支：git branch xxx<br>切换分支：git checkout<br>创建+切换分支：git checkout -b<br>合并某分支到当前分支：git merge<br>删除分支：git branch -d</p><h5 id="Git发现冲突怎么办"><a href="#Git发现冲突怎么办" class="headerlink" title="Git发现冲突怎么办"></a>Git发现冲突怎么办</h5><ol><li>将自己的代码提交至本地仓库 git add git commit</li><li>切换开发分支，从远程仓库拉取代码 git pull</li><li>使用git merge合并分支</li><li>git push 推送分支</li></ol><p>![image-20230510153525859](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510153525859.png)</p><p>![image-20230510153703459](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510153703459.png)</p><p>![image-20230510153757540](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510153757540.png)</p><p>![image-20230510160115159](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510160115159.png)</p><p>![image-20230510163316006](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510163316006.png)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note_React</title>
      <link href="/2023/03/10/Note-React/"/>
      <url>/2023/03/10/Note-React/</url>
      
        <content type="html"><![CDATA[<h1 id="React笔记"><a href="#React笔记" class="headerlink" title="React笔记"></a>React笔记</h1><h3 id="React特点："><a href="#React特点：" class="headerlink" title="React特点："></a>React特点：</h3><ul><li>虚拟DOM<ol><li>避免操作实际DOM的繁复操作，降低API复杂度</li><li>避免兼容性问题</li><li>拥有更好的性能</li></ol></li><li>声明式编程——JSX（JS Extension）</li><li>基于组件的——可复用性，解耦合</li></ul><h3 id="React-三个-API："><a href="#React-三个-API：" class="headerlink" title="React 三个 API："></a>React 三个 API：</h3><ol><li>React.createElement()<ul><li>标签名必须小写</li><li>属性中事件必须用驼峰命名法，值为一个函数。&#x2F;&#x2F;  Class属性需要使用className</li><li>注意：React的虚拟DOM最后都会变成真实DOM。React的元素一旦创建，无法再修改，只能通过重新创建来替换。</li></ul></li><li>React.createRoot()</li><li>ReactObject.render()<ul><li>调用render渲染页面时，会对比两次虚拟DOM，DOM 差分算法（DOM diffing algorithm），只在真实DOM中替换变更的。</li><li>React确保每次渲染对真实DOM做最少的修改</li></ul></li></ol><h3 id="JSX（JavaScript-Syntax-Extension）"><a href="#JSX（JavaScript-Syntax-Extension）" class="headerlink" title="JSX（JavaScript Syntax Extension）"></a>JSX（JavaScript Syntax Extension）</h3><p> JSX 是 React.createElement()的语法糖，JSX在执行前会被Babel转换为JS代码</p><p>注意：</p><ol><li>JSX不是字符串</li><li>JSX中，HTML标签小写，React组件首字母大写</li><li>JSX只有一个根标签</li><li>JSX标签必须正确结束  eg:&lt;input type:’text’&#x2F;&gt;</li><li>JSX可以用{}嵌入表达式，但表达式值为bool，null，undefined，不会显示</li><li>JSX中属性可以直接在标签中设置，但是class替换为className,style要用对象，</li></ol><h3 id="虚拟DOM"><a href="#虚拟DOM" class="headerlink" title="虚拟DOM"></a>虚拟DOM</h3><p>JSX显示 <li> 时候，每个元素都要有一个唯一key。没有key的话，React的DOM比较算法就是顺序比较，如果数组头部内容变化，后面都会变化，会导致性能问题。所以要设置一个key作为id的作用，这样在比较DOM时，按照ID比较。</p><p>一般在开发中，将数据的id作为key。React默认使用数组的索引作为key。</p><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ol><li><p>函数组件</p><p>() &#x3D;&gt; { return <div>我是函数组件</div> } &#x2F; function (){  }</p><p>VScode rfc可以创建代码块</p></li><li><p>类组件</p></li></ol><h3 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h3><ul><li>用于父组件向子组件传递参数</li><li>xxx&#x3D;{}来传递      props.xxx来使用</li><li>props.children表示标签内的内容</li><li>props.className表示标签的类名</li><li>`   &#96;叫作模板字符串</li></ul><h3 id="State与生命周期"><a href="#State与生命周期" class="headerlink" title="State与生命周期"></a>State与生命周期</h3><ul><li>React中，组件渲染完毕，在修改组件的变量，是不会重新渲染的。需要一个特殊变量记录，且会重新渲染页面。</li><li><strong>需要用钩子函数useState()</strong></li><li>函数返回两个值，第一个是值本身，第二个是set函数。可用解构语法赋值。</li><li>state其实就是一个变量的值，在调用setState修改变量值的时候，且变量值改变时，才会重新调用react渲染。 </li><li>setState()是异步执行的，不是改完立刻生效的。——<strong>所以当setState()调用需要用到旧state值时，可能出现计算出错</strong></li><li><strong>为了避免上面这种情况，通过回调函数的形式来修改state</strong>——setState((state) &#x3D;&gt; { return state }) React会确保将最新的state值作为参数传递。</li><li><strong>setState()的执行流程：</strong>setState() -&gt; ReactDOM dispatchSetDate() -&gt; 判断组件处于什么阶段 1.渲染阶段：不会检查state值是否相同 2.非渲染阶段：会检查state值是否相同，值不同时会将组件挂在到渲染队列上，重新渲染。（在值相同时，React在一些情况下会继续执行当前组件的渲染，但这个渲染不会触发子组件渲染，且不实际生效  <strong>某些情况：值第一次相同</strong>）</li></ul><h3 id="在React中获取原生DOM"><a href="#在React中获取原生DOM" class="headerlink" title="在React中获取原生DOM"></a>在React中获取原生DOM</h3><ol><li><p>通过document进行DOM操作</p></li><li><p>通过React获取DOM对象</p><ol><li><p>创建存储DOM容器——useRef() 钩子函数  默认返回{current : undefined} 简单的js对象。</p><p>​所以直接创建一个js对象{current : null}，也可以。但是区别：我们创建的对象，每次重新渲染会获得一个新对象。useRef会确保每次获得同一个对象。</p></li><li><p>将容器设置为想要获取DOM对象元素的ref&#x3D;{ref}属性</p></li></ol></li></ol><h3 id="HOOK钩子函数注意事项"><a href="#HOOK钩子函数注意事项" class="headerlink" title="HOOK钩子函数注意事项"></a>HOOK钩子函数注意事项</h3><ol><li>钩子函数只能在React中的函数组件和自定义钩子函数中使用</li><li>钩子函数只能在函数组件中调用，不能在组件内新建函数里调用。</li></ol><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><ul><li>VScode rcc自动创建代码片段。</li><li>类组件的Props，可通过实例对象直接访问。this.props </li><li>类组件的state，可通过实例对象直接访问。this.state。并通过this.setState()对其进行修改。</li></ul><h3 id="Portal"><a href="#Portal" class="headerlink" title="Portal"></a>Portal</h3><ul><li>子组件通常作为父组件的后代渲染到页面上。</li><li><strong>通过Portal可以将组件渲染到页面上的指定位置。</strong></li><li>使用方法<ol><li>在index.html中添加一个新元素</li><li>修改组件的渲染方式 通过ReactDom.createPortal() 作为返回值创建元素。 方法有两个参数，一个是jsx原先返回的代码，一个是目标位置的DOM元素。</li></ol></li></ul><h3 id="React中的CSS"><a href="#React中的CSS" class="headerlink" title="React中的CSS"></a>React中的CSS</h3><ul><li>CSS模块 使用步骤<ol><li>创建一个xxx.module.css</li><li>在项目中通过import引入  import classes(起个名字) from ‘xxx.module.css’</li><li>通过classes设置类  className&#x3D;{classes.p1}</li></ol></li></ul><h3 id="React中的Context"><a href="#React中的Context" class="headerlink" title="React中的Context"></a>React中的Context</h3><ul><li>Context相当于一个公共存储空间</li><li>我们可将多个组件公用的数据，存入context而不用通过props逐层传递</li><li>使用方法<ol><li>通过React.createContext(defaultValue)创建context 并导出</li><li>在目标组件js中导入context<ol><li>使用&lt;Context.Consumer&gt;创建标签，内部需要一个回调函数，参数为ctx。可通过ctx访问创建Context时传入的数据。</li><li>Context.Provider表示数据生产者可以通过value属性定义context中存储的数据。使得该组件中所有的子组件都能访问到Context </li><li>通过Context访问数据时，会优先访问离他最近的provider中的数据</li><li>使用钩子函数useContext(xxx)获取context，将Context中数据作为返回值返回。</li></ol></li></ol></li></ul><h3 id="Effect函数"><a href="#Effect函数" class="headerlink" title="Effect函数"></a>Effect函数</h3><ul><li>React组件有部分逻辑都可以直接编写到组件的函数体中的，像是对数组调用filter、map等方法，像是判断某个组件是否显示等。但是有一部分逻辑如果直接写在函数体中，会影响到组件的渲染，这部分会产生“副作用”的代码，是一定不能直接写在函数体中。</li><li>例如，如果直接将修改state的逻辑编写到了组件之中，就会导致组件不断的循环渲染，直至调用次数过多内存溢出。</li><li>通过useEffect(() &#x3D;&gt; {})将有副作用的代码放到里面执行<code>useEffect()</code>中的回调函数会在组件每次渲染完毕之后执行，这也是它和写在函数体中代码的最大的不同，函数体中的代码会在组件渲染前执行，而<code>useEffect()</code>中的代码是在组件渲染后才执行，这就避免了代码的执行影响到组件渲染。</li><li>依赖项数组，指定后只有在依赖项发生变化时，useEffect才会执行。如果为空数组，则只会在初始化时出发一次</li><li>Effect 回调函数最后可以返回一个函数，作为effect 的清理函数，在下次useEffect执行前执行。在这个函数中可以做一些工作，清除上个回调函数带来的影响例如开定时器</li></ul><h3 id="React中的memo函数"><a href="#React中的memo函数" class="headerlink" title="React中的memo函数"></a>React中的memo函数</h3><ul><li>它是一个高阶函数，接受一个组件作为输入，返回一个包装过的新组件</li><li>包装后具有缓存功能，<strong>只有props发生变化，才会触发新的渲染，否则一直返回缓存内的。</strong></li></ul><h3 id="React中的useCallback"><a href="#React中的useCallback" class="headerlink" title="React中的useCallback()"></a>React中的useCallback()</h3><ul><li>参数<ol><li>回调函数</li><li>依赖数组，只有依赖数组中的变量发生变化时，回调函数才会重新创建 。不设置依赖数组则每回渲染都会重新创建。 依赖数组为空，则只会在组件初始化时才会重新创建。</li><li>![image-20230510164753478](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510164753478.png)</li></ol></li></ul><h3 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h3><p><a href="https://so.csdn.net/so/search?q=useReducer&spm=1001.2101.3001.7020">useReducer</a>的使用场景：<br>当一个state需要维护多个数据且它们之间互相依赖。<br>这样业务代码中只需要通过dispatch来更新state，繁杂的逻辑都在reducer函数中了。</p><p>![image-20230510164717388](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510164717388.png)</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><p>![image-20230510164953724](&#x2F;Users&#x2F;gengjianing&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230510164953724.png)</p><h3 id="React中的自定义钩子"><a href="#React中的自定义钩子" class="headerlink" title="React中的自定义钩子"></a>React中的自定义钩子</h3><ul><li>React的钩子函数只能在函数组件和自定义钩子中应用</li><li>React的自定义钩子是一个以use开头的普通函数</li></ul><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><ul><li>Redux是<strong>一个专为JS应用设计的可预期的状态容器</strong></li><li>可预期：Redux中的各种操作结果是确定的，通过Reducer来实现</li><li>容器：对React中的各种状态State进行管理，增删改查。</li><li>Redux可以理解为Reducer和Context的结合体。Reducer可以管理复杂的state，提炼并消除冗余代码。Context使得State可以更加方便的传递，而不是使用props自上而下的一层一层传递。</li></ul><h3 id="ReduxToolkit（RTK）"><a href="#ReduxToolkit（RTK）" class="headerlink" title="ReduxToolkit（RTK）"></a>ReduxToolkit（RTK）</h3><ul><li><p>安装 npm install react-redux @reduxjs&#x2F;toolkit</p></li><li><p>帮助我们处理redux冗余操作</p></li><li><p>createSlice()创造reducer切片，传入一个配置对象作为参数{</p><p>​name:’’用于生成action的type</p><p>​initialState:{}state初始值</p><p>​reducers:{</p><p>​方法:setName(state, action){}, setAge{}… 传入的参数是代理对象，可以直接修改，无需解构再修改</p><p>}指定对于state各种操作</p><p>}</p></li><li><p>slice.actions 自动生成action创建器函数，调用函数自动创建actioin对象。{type:’&#x2F;name&#x2F;函数名’，payload:函数参数}</p></li><li><p>configureStore()通过slice创建store对象，参数为配置对象{</p><p>​reducer:{</p><p>​student: slice.reducer</p><p>​}</p><p>}</p></li><li><p>export store对象</p></li><li><p><Provider store={store}>标签包裹app，然后传入store。</p></li><li><p>useSelecter()获取state数据</p></li><li><p>useDispatch()获取派发器对象，dispatch(setName(“沙和尚”))传入参数是action.payload</p></li></ul><h3 id="React-Router"><a href="#React-Router" class="headerlink" title="React-Router"></a>React-Router</h3><ul><li><p>两种模式History模式对应BrowserRouter，Hash模式对应HashRouter</p></li><li><p>写法</p><ul><li><p>组件写法</p><Browser><p>​<Routes></p><p>​&lt;Route path&#x3D;’&#x2F;‘ element&#x3D;{<App/>}&gt;</p><p>​&lt;Route path&#x3D;’&#x2F;Home’ element&#x3D;{<Home/>}&gt;</p><ul><li>在main中引入Router，且替换掉App组件</li><li>在App组件中，引入Outlet占位符，类似于展示组件的窗口</li></ul></li><li><p>路由表写法(对象)</p><p>const route &#x3D; [</p><p>​{</p><p>​path:’&#x2F;‘,</p><p>​element:’’</p><p>​}</p><p>]</p><ul><li>main中使用<BrowserRouter>包裹<App></li></ul></li></ul></li><li></li><li><p>路由重定向，将Route中的element设置为Navigate组件，并设置to</p></li></ul><h3 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h3><ul><li><p>React16之前</p></li><li><p><img src="/../images/React_smzq.png" alt="React生命周期"></p></li><li><p>React16之后</p></li><li><p>安装 当组件的实例被创建并插入到 DOM 中时，这些方法按以下顺序调用：</p><p> constructor()</p><p> static getDerivedStateFromProps() </p><p> render()</p><p> componentDidMount()</p><p> 更新中 更新可能由道具或状态的更改引起。当重新渲染组件时，这些方法按以下顺序调用：</p><p> static getDerivedStateFromProps()</p><p> shouldComponentUpdate()</p><p> render() getSnapshotBeforeUpdate()</p><p> componentDidUpdate() </p><p>卸载 当组件从 DOM 中移除时调用此方法： </p><p> componentWillUnmount()</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay03</title>
      <link href="/2023/03/06/%E5%89%91%E6%8C%87offerDay03/"/>
      <url>/2023/03/06/%E5%89%91%E6%8C%87offerDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——字符串（简单）"><a href="#剑指offerDay02——字符串（简单）" class="headerlink" title="剑指offerDay02——字符串（简单）"></a>剑指offerDay02——字符串（简单）</h1><h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h2><p><img src="/../images/offer05.png" alt="offer05"></p><p>💡思路：</p><ul><li>新建一个StringBuilder，逐字符复制，遇到空格则用“%20”替代</li><li>原地修改更省内存</li></ul><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;        StringBuilder res = new StringBuilder();        for(Character c : s.toCharArray())        &#123;            if(c == &#39; &#39;) res.append(&quot;%20&quot;);            else res.append(c);        &#125;        return res.toString();    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay02</title>
      <link href="/2023/03/04/%E5%89%91%E6%8C%87offerDay02/"/>
      <url>/2023/03/04/%E5%89%91%E6%8C%87offerDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——链表（简单）"><a href="#剑指offerDay02——链表（简单）" class="headerlink" title="剑指offerDay02——链表（简单）"></a>剑指offerDay02——链表（简单）</h1><h2 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06 从尾到头打印链表"></a>剑指offer 06 从尾到头打印链表</h2><p><img src="/../images/offer06.png" alt="offer06"></p><p>💡思路：</p><ul><li>递归法，先递归到达链表尾部，再用push(head.val)将节点值添加进数组</li><li>循环法，JS可以用数组的unshift方法来从头插入数据，也可以用push + reverse 操作</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.unshift(head.val)        head = head.next    &#125;    return res&#125;;var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.push(head.val)        head = head.next    &#125;    return res.reverse()&#125;;var reversePrint = function (head) &#123;    if(!head) return []    let result = reversePrint(head.next)    result.push(head.val);    return result&#125;;</code></pre><h2 id="剑指offer24-反转链表"><a href="#剑指offer24-反转链表" class="headerlink" title="剑指offer24 反转链表"></a>剑指offer24 反转链表</h2><p><img src="/../images/offer24.png" alt="offer24"></p><p>💡思路：</p><ul><li>JS ES6中的解构语法，可以很好的进行赋值。</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123;    let [p,c] = [null, head]    while(c)&#123;        [c.next,c,p] = [p,c.next,c]    &#125;    return p&#125;;</code></pre><h2 id="剑指offer35-复杂链表的复制"><a href="#剑指offer35-复杂链表的复制" class="headerlink" title="剑指offer35 复杂链表的复制"></a>剑指offer35 复杂链表的复制</h2><p><img src="/../images/offer35_1.png" alt="offer35_1"></p><p><img src="/../images/offer35_2.png" alt="offer35_2"></p><p>💡思路：</p><ul><li>使用hash Map简历原节点 -&gt; 新节点的映射，先复制普通的val与next指针，后根据Map复制random指针<ol><li>复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</li><li>构建新链表的 next 和 random 指向</li><li>返回新链表的头节点</li></ol></li><li>也可先直接将新节点与旧节点连接至一个列表上，再进行新旧列表的拆分。<ol><li>复制各节点，并构建拼接链表</li><li>构建各新节点的 random 指向</li><li>拆分两链表</li></ol></li></ul><pre><code class="javascript">/** * // Definition for a Node. * function Node(val, next, random) &#123; *    this.val = val; *    this.next = next; *    this.random = random; * &#125;; *//** * @param &#123;Node&#125; head * @return &#123;Node&#125; */var copyRandomList = function(head) &#123;    if(head === null)&#123;        return head    &#125;    let curr = head    let newHead = new Node()    let newCurr = newHead    let map = new Map()    while(curr)&#123;        newCurr.val = curr.val        newCurr.next = curr.next ? new Node() : null                map.set(curr, newCurr)        newCurr = newCurr.next        curr = curr.next    &#125;    newCurr = newHead    while(head)&#123;        newCurr.random = head.random ? map.get(head.random) : null        head = head.next        newCurr = newCurr.next    &#125;    return newHead&#125;;// 拼接+拆分链表，空间复杂度O(1)var copyRandomList = function(head)&#123;    if(!head) return head;    let node = head;    // 复制节点，将新节点放到原节点后面    while(node)&#123;        node.next = new Node(node.val, node.next);        node = node.next.next;    &#125;    node = head;    // 构建新节点的random指向    while(node)&#123;        if(node.random !== null) node.next.random = node.random.next;        node = node.next.next;    &#125;    // 拆分链表    let newNode = head.next, res = newNode;    node = head;    while(node.next &amp;&amp; newNode.next)&#123;        node.next = node.next.next;        newNode.next = newNode.next.next;        node = node.next;        newNode = newNode.next;    &#125;    node.next= null;    // 返回新链表的头结点    return res;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay01</title>
      <link href="/2023/03/03/%E5%89%91%E6%8C%87offerDay01/"/>
      <url>/2023/03/03/%E5%89%91%E6%8C%87offerDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay01——栈与队列（简单）"><a href="#剑指offerDay01——栈与队列（简单）" class="headerlink" title="剑指offerDay01——栈与队列（简单）"></a>剑指offerDay01——栈与队列（简单）</h1><h2 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09 用两个栈实现队列"></a>剑指offer 09 用两个栈实现队列</h2><p><img src="/../images/offer09.png" alt="offer09"></p><p>💡<strong>思路</strong>：</p><ul><li>两个栈分别作用是<strong>入队栈</strong>、<strong>出队栈</strong></li><li><strong>appendTail</strong>方法直接在入队栈内push</li><li><strong>deleteHead</strong>方法需要检查两个栈的长度，先判断出队栈，再判断入队栈。<ol><li>均为空 -&gt; 队列为空</li><li>出队空，入队不空 -&gt; 先用out.push(in.pop)操作将入队栈的元素放入出队栈（两个栈的特性自然维护队列的特性），再pop出队栈.</li></ol></li></ul><pre><code class="javascript">var CQueue = function() &#123;    this.inStack = [];    this.outStack = [];&#125;;/**  * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123;    this.inStack.push(value);&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123;    if (!this.outStack.length) &#123;        if (!this.inStack.length) &#123;            return -1;        &#125;        this.in2out();    &#125;    return this.outStack.pop();&#125;;CQueue.prototype.in2out = function() &#123;    while (this.inStack.length) &#123;        this.outStack.push(this.inStack.pop());    &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */</code></pre><h2 id="剑指offer-30-包含min函数的栈"><a href="#剑指offer-30-包含min函数的栈" class="headerlink" title="剑指offer 30 包含min函数的栈"></a>剑指offer 30 包含min函数的栈</h2><p><img src="/../images/offer30.png" alt="offer30"></p><p>💡<strong>思路</strong>：</p><ul><li>设置辅助栈，原栈push时，min栈同时保存当前整个栈的min值，即push当前元素和min栈栈顶元素更小的那一个。</li><li>注意开始辅助栈，放入无穷大（Infinity）</li></ul><pre><code class="JavaScript">var MinStack = function() &#123;    this.x_stack = [];    this.min_stack = [Infinity];&#125;;MinStack.prototype.push = function(x) &#123;    this.x_stack.push(x);    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));&#125;;MinStack.prototype.pop = function() &#123;    this.x_stack.pop();    this.min_stack.pop();&#125;;MinStack.prototype.top = function() &#123;    return this.x_stack[this.x_stack.length - 1];&#125;;MinStack.prototype.min = function() &#123;    return this.min_stack[this.min_stack.length - 1];&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>你好Hexo<br>你好世界<br><a href="https://craiggeng.github.io/">我的Github个人网站</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/31/hello-world/"/>
      <url>/2022/08/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

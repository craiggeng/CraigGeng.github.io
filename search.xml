<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>js_20230619</title>
      <link href="/2023/06/23/js-20230619/"/>
      <url>/2023/06/23/js-20230619/</url>
      
        <content type="html"><![CDATA[<!-- ---title: '=='与'==='date: 2023-06-19 21:20:36tags: JavaScript Basic-Knowledge Interview--- --><h1 id="JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’"><a href="#JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’" class="headerlink" title="JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’"></a>JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>“&#x3D;&#x3D;“叫做相等运算符，”&#x3D;&#x3D;&#x3D;”叫做严格运算符</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>对于String, number这些基础类型，&#x3D;&#x3D;操作符会先把两边的变量进行类型强制转换成相同的类型再比较是否相等；&#x3D;&#x3D;&#x3D;操作符则不会进行类型转换，而是直接进行比较。</li><li>对于array, object这些高级类型，&#x3D;&#x3D;和 &#x3D;&#x3D;&#x3D;是没有区别的，因为它们比较的是 “指针地址” 。</li><li>对于基础类型和高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;是有区别的；&#x3D;&#x3D;操作符会先把高级类型转换为基础类型之后，进行<strong>值的比较</strong>；&#x3D;&#x3D;&#x3D;操作符则不会进行转换，<strong>类型比较</strong>，如果不同，直接返回false</li></ol><pre><code class="javascript">examle:    66 == &#39;66&#39; // True    66 === &#39;66&#39; // False</code></pre><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>对于特殊值NaN（Not a Number），表示非数字，NaN和任何数（包括它自己）做相等比较，都会返回false，所以判断NaN最好用isNaN()函数</li><li>null和undefined，两者值比较为True（&#x3D;&#x3D;），类型比较为False（&#x3D;&#x3D;&#x3D;）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript Basic-Knowledge Interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay03</title>
      <link href="/2023/03/06/%E5%89%91%E6%8C%87offerDay03/"/>
      <url>/2023/03/06/%E5%89%91%E6%8C%87offerDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——字符串（简单）"><a href="#剑指offerDay02——字符串（简单）" class="headerlink" title="剑指offerDay02——字符串（简单）"></a>剑指offerDay02——字符串（简单）</h1><h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h2><p><img src="/../images/offer05.png" alt="offer05"></p><p>💡思路：</p><ul><li>新建一个StringBuilder，逐字符复制，遇到空格则用“%20”替代</li><li>原地修改更省内存</li></ul><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;        StringBuilder res = new StringBuilder();        for(Character c : s.toCharArray())        &#123;            if(c == &#39; &#39;) res.append(&quot;%20&quot;);            else res.append(c);        &#125;        return res.toString();    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay02</title>
      <link href="/2023/03/04/%E5%89%91%E6%8C%87offerDay02/"/>
      <url>/2023/03/04/%E5%89%91%E6%8C%87offerDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——链表（简单）"><a href="#剑指offerDay02——链表（简单）" class="headerlink" title="剑指offerDay02——链表（简单）"></a>剑指offerDay02——链表（简单）</h1><h2 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06 从尾到头打印链表"></a>剑指offer 06 从尾到头打印链表</h2><p><img src="/../images/offer06.png" alt="offer06"></p><p>💡思路：</p><ul><li>递归法，先递归到达链表尾部，再用push(head.val)将节点值添加进数组</li><li>循环法，JS可以用数组的unshift方法来从头插入数据，也可以用push + reverse 操作</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.unshift(head.val)        head = head.next    &#125;    return res&#125;;var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.push(head.val)        head = head.next    &#125;    return res.reverse()&#125;;var reversePrint = function (head) &#123;    if(!head) return []    let result = reversePrint(head.next)    result.push(head.val);    return result&#125;;</code></pre><h2 id="剑指offer24-反转链表"><a href="#剑指offer24-反转链表" class="headerlink" title="剑指offer24 反转链表"></a>剑指offer24 反转链表</h2><p><img src="/../images/offer24.png" alt="offer24"></p><p>💡思路：</p><ul><li>JS ES6中的解构语法，可以很好的进行赋值。</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123;    let [p,c] = [null, head]    while(c)&#123;        [c.next,c,p] = [p,c.next,c]    &#125;    return p&#125;;</code></pre><h2 id="剑指offer35-复杂链表的复制"><a href="#剑指offer35-复杂链表的复制" class="headerlink" title="剑指offer35 复杂链表的复制"></a>剑指offer35 复杂链表的复制</h2><p><img src="/../images/offer35_1.png" alt="offer35_1"></p><p><img src="/../images/offer35_2.png" alt="offer35_2"></p><p>💡思路：</p><ul><li>使用hash Map简历原节点 -&gt; 新节点的映射，先复制普通的val与next指针，后根据Map复制random指针<ol><li>复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</li><li>构建新链表的 next 和 random 指向</li><li>返回新链表的头节点</li></ol></li><li>也可先直接将新节点与旧节点连接至一个列表上，再进行新旧列表的拆分。<ol><li>复制各节点，并构建拼接链表</li><li>构建各新节点的 random 指向</li><li>拆分两链表</li></ol></li></ul><pre><code class="javascript">/** * // Definition for a Node. * function Node(val, next, random) &#123; *    this.val = val; *    this.next = next; *    this.random = random; * &#125;; *//** * @param &#123;Node&#125; head * @return &#123;Node&#125; */var copyRandomList = function(head) &#123;    if(head === null)&#123;        return head    &#125;    let curr = head    let newHead = new Node()    let newCurr = newHead    let map = new Map()    while(curr)&#123;        newCurr.val = curr.val        newCurr.next = curr.next ? new Node() : null                map.set(curr, newCurr)        newCurr = newCurr.next        curr = curr.next    &#125;    newCurr = newHead    while(head)&#123;        newCurr.random = head.random ? map.get(head.random) : null        head = head.next        newCurr = newCurr.next    &#125;    return newHead&#125;;// 拼接+拆分链表，空间复杂度O(1)var copyRandomList = function(head)&#123;    if(!head) return head;    let node = head;    // 复制节点，将新节点放到原节点后面    while(node)&#123;        node.next = new Node(node.val, node.next);        node = node.next.next;    &#125;    node = head;    // 构建新节点的random指向    while(node)&#123;        if(node.random !== null) node.next.random = node.random.next;        node = node.next.next;    &#125;    // 拆分链表    let newNode = head.next, res = newNode;    node = head;    while(node.next &amp;&amp; newNode.next)&#123;        node.next = node.next.next;        newNode.next = newNode.next.next;        node = node.next;        newNode = newNode.next;    &#125;    node.next= null;    // 返回新链表的头结点    return res;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay01</title>
      <link href="/2023/03/03/%E5%89%91%E6%8C%87offerDay01/"/>
      <url>/2023/03/03/%E5%89%91%E6%8C%87offerDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay01——栈与队列（简单）"><a href="#剑指offerDay01——栈与队列（简单）" class="headerlink" title="剑指offerDay01——栈与队列（简单）"></a>剑指offerDay01——栈与队列（简单）</h1><h2 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09 用两个栈实现队列"></a>剑指offer 09 用两个栈实现队列</h2><p><img src="/../images/offer09.png" alt="offer09"></p><p>💡<strong>思路</strong>：</p><ul><li>两个栈分别作用是<strong>入队栈</strong>、<strong>出队栈</strong></li><li><strong>appendTail</strong>方法直接在入队栈内push</li><li><strong>deleteHead</strong>方法需要检查两个栈的长度，先判断出队栈，再判断入队栈。<ol><li>均为空 -&gt; 队列为空</li><li>出队空，入队不空 -&gt; 先用out.push(in.pop)操作将入队栈的元素放入出队栈（两个栈的特性自然维护队列的特性），再pop出队栈.</li></ol></li></ul><pre><code class="javascript">var CQueue = function() &#123;    this.inStack = [];    this.outStack = [];&#125;;/**  * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123;    this.inStack.push(value);&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123;    if (!this.outStack.length) &#123;        if (!this.inStack.length) &#123;            return -1;        &#125;        this.in2out();    &#125;    return this.outStack.pop();&#125;;CQueue.prototype.in2out = function() &#123;    while (this.inStack.length) &#123;        this.outStack.push(this.inStack.pop());    &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */</code></pre><h2 id="剑指offer-30-包含min函数的栈"><a href="#剑指offer-30-包含min函数的栈" class="headerlink" title="剑指offer 30 包含min函数的栈"></a>剑指offer 30 包含min函数的栈</h2><p><img src="/../images/offer30.png" alt="offer30"></p><p>💡<strong>思路</strong>：</p><ul><li>设置辅助栈，原栈push时，min栈同时保存当前整个栈的min值，即push当前元素和min栈栈顶元素更小的那一个。</li><li>注意开始辅助栈，放入无穷大（Infinity）</li></ul><pre><code class="JavaScript">var MinStack = function() &#123;    this.x_stack = [];    this.min_stack = [Infinity];&#125;;MinStack.prototype.push = function(x) &#123;    this.x_stack.push(x);    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));&#125;;MinStack.prototype.pop = function() &#123;    this.x_stack.pop();    this.min_stack.pop();&#125;;MinStack.prototype.top = function() &#123;    return this.x_stack[this.x_stack.length - 1];&#125;;MinStack.prototype.min = function() &#123;    return this.min_stack[this.min_stack.length - 1];&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>你好Hexo<br>你好世界<br><a href="https://craiggeng.github.io/">我的Github个人网站</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/31/hello-world/"/>
      <url>/2022/08/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浏览器的缓存机制</title>
      <link href="/2023/06/25/web-20230625/"/>
      <url>/2023/06/25/web-20230625/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h1><p><img src="/Users/gengjianing/blog/source/images/web_20230625.png" alt="web_20230625"></p><ul><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ul><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p><p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol><h6 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h6><p>Expires是HTTP&#x2F;1.0控制网页缓存的字段，其值为服务器返回该请求结果<code>缓存的到期时间</code>，即再次发起该请求时，如果客户端的时间小于Expires的值时，直接使用缓存结果。</p><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在HTTP&#x2F;1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li>max-age&#x3D;xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag &#x2F; If-None-Match的优先级比Last-Modified &#x2F; If-Modified-Since高。协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果</li></ol><h5 id="Last-Modified-x2F-If-Modified-Since"><a href="#Last-Modified-x2F-If-Modified-Since" class="headerlink" title="Last-Modified &#x2F; If-Modified-Since"></a>Last-Modified &#x2F; If-Modified-Since</h5><p>Last-Modified是服务器响应请求时，返回该资源文件在服务器最后被修改的时间，</p><p>If-Modified-Since则是客户端再次发起该请求时，携带上次请求返回的Last-Modified值，通过此字段值告诉服务器该资源上次请求返回的最后被修改时间。服务器收到该请求，发现请求头含有If-Modified-Since字段，则会根据If-Modified-Since的字段值与该资源在服务器的最后被修改时间做对比，若服务器的资源最后被修改时间大于If-Modified-Since的字段值，则重新返回资源，状态码为200；否则则返回304，代表资源无更新，可继续使用缓存文件，</p><h5 id="Etag-x2F-If-None-Match"><a href="#Etag-x2F-If-None-Match" class="headerlink" title="Etag &#x2F; If-None-Match"></a>Etag &#x2F; If-None-Match</h5><p>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)</p><p>通常服务器生成并返回在Etag中的验证码，常常是文件内容的哈希值或者某个其他指纹码。客户端不必了解指纹码是如何生成的，只需要在下一个请求中将其发送给服务器(浏览器默认会添加)：如果指纹码仍然一致，说明资源未被修改，服务器会返回304 Not Modified，这样我们就可以跳过下载，利用已经缓存了的资源，并且该资源会继续缓存120s。</p><p>If-None-Match是客户端再次发起该请求时，携带上次请求返回的唯一标识Etag值，通过此字段值告诉服务器该资源上次请求返回的唯一标识值。服务器收到该请求后，发现该请求头中含有If-None-Match，则会根据If-None-Match的字段值与该资源在服务器的Etag值做对比，一致则返回304，代表资源无更新，继续使用缓存文件；不一致则重新返回资源文件，状态码为200，如下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> 缓存机制 </tag>
            
            <tag> 强制缓存 </tag>
            
            <tag> 协商缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>节流与防抖</title>
      <link href="/2023/06/24/js-20230624-2/"/>
      <url>/2023/06/24/js-20230624-2/</url>
      
        <content type="html"><![CDATA[<h1 id="节流与防抖"><a href="#节流与防抖" class="headerlink" title="节流与防抖"></a>节流与防抖</h1><p><strong>函数防抖（debounce）</strong> <strong>函数节流（throttle）</strong> 都是为了限制函数的执行频次，以优化函数触发频率过高导致的响应速度跟不上触发频率，出现延迟或卡顿的现象。</p><h2 id="防抖（Debounce）"><a href="#防抖（Debounce）" class="headerlink" title="防抖（Debounce）"></a>防抖（Debounce）</h2><p><strong>防抖：</strong> 触发高频事件，n秒后，函数会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。</p><p>如下图，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会执行handle函数。</p><p><img src="/../images/js_20230624_1.png" alt="js_20230624_1"></p><pre><code class="javascript">function debounce(fn, delay)&#123;    let timer = null    return function() &#123;        if(timer) clearTimeout(timer)             timer = setTimeout(() =&gt; &#123;            fn.apply(this, arguments);            timer = null        &#125;, delay)    &#125;&#125;</code></pre><h2 id="节流（throttle）"><a href="#节流（throttle）" class="headerlink" title="节流（throttle）"></a>节流（throttle）</h2><p><strong>节流：</strong>高频事件触发，但在n秒内只会执行一次真正的事件处理函数，所以节流会稀释函数的执行频率。原理是通过判断是否有延迟调用函数未执行。</p><p>如下图，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。</p><p><img src="/../images/js_20230624_2.png" alt="js_20230624_2"></p><pre><code class="javascript">function throttle(fn, delay)&#123;  let timer = null  return function()&#123;    if(timer) return    timer = setTimeout(()=&gt;&#123;      fn.apply(this, arguments)      timer = null    &#125;,delay)  &#125;&#125;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ES6新特性解析</title>
      <link href="/2023/06/24/js-20230624-1/"/>
      <url>/2023/06/24/js-20230624-1/</url>
      
        <content type="html"><![CDATA[<h1 id="ES6新特性解析"><a href="#ES6新特性解析" class="headerlink" title="ES6新特性解析"></a>ES6新特性解析</h1><h2 id="ES6语法中箭头函数-x3D-gt-与function的区别？"><a href="#ES6语法中箭头函数-x3D-gt-与function的区别？" class="headerlink" title="ES6语法中箭头函数()&#x3D;&gt;{} 与function的区别？"></a>ES6语法中箭头函数()&#x3D;&gt;{} 与function的区别？</h2><ol><li><strong>this的指向</strong>：使用<strong>function</strong>定义的函数，this的指向随着调用环境的变化而<strong>变化的</strong>，而<strong>箭头函数</strong>中的this指向是<strong>固定不变的</strong>，永远指向它定义时的上层作用域中的this，即一直指向的是定义函数的环境</li><li><strong>构造函数</strong>：function是可以定义构造函数的，而箭头函数是不行的。</li><li><strong>变量提升</strong>：由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升。<strong>故箭头函数一定要定义于调用之前！</strong>（function不用）</li><li>箭头函数只能声明<strong>匿名函数</strong>可通过表达式让函数具名，function既可以声明匿名也可由声明具名函数</li></ol><h2 id="var、let、const的区别？"><a href="#var、let、const的区别？" class="headerlink" title="var、let、const的区别？"></a>var、let、const的区别？</h2><ol><li><p><strong>作用域</strong>：<strong>let</strong>和<strong>const</strong>具有块级作用域，<strong>var</strong>不存在块级作用域,可以跨块访问, 不能跨函数访问。<strong>var出来的变量是全局的，但是不能跨函数访问</strong></p></li><li><p><strong>变量提升</strong>：什么是变量提升？变量能在声明之前使用，就是变量提升。<strong>var存在变量提升，let和const不存在变量提升</strong> var在js中是支持预解析的声明出来的就不会报错是undefined，let，const就会报错</p></li><li><p><strong>全局属性</strong>：浏览器的全局对象是window。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性（window.a 可以访问到），但是let和const不会</p></li><li><p><strong>重复声明</strong>：let const不可重复声明，var可以只会记录最后一个值。</p></li><li><p><strong>暂时性死区</strong>：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区</p></li><li><p><strong>初始值</strong>：<strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</strong></p></li><li><p><strong>指针指向</strong>：let和const都是ES6新语法， let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p></li><li><p><strong>应用场景</strong>：</p><p>块级作用域解决了ES5中的两个问题：</p><ul><li>内层变量可能覆盖外层变量</li><li>用来计数的循环变量泄露为全局变量</li></ul><p><strong>应用场景：以后声明变量使用 let 就对了</strong></p><p><strong>应用场景：声明对象类型使用 const，非对象类型声明选择 let</strong></p><p><strong>没有特殊情况就不要用var了</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> ES6 </tag>
            
            <tag> const, </tag>
            
            <tag> var </tag>
            
            <tag> let </tag>
            
            <tag> 箭头函数 </tag>
            
            <tag> function函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS实现元素水平垂直居中</title>
      <link href="/2023/06/24/css-20230624-1/"/>
      <url>/2023/06/24/css-20230624-1/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS实现元素水平垂直居中"><a href="#CSS实现元素水平垂直居中" class="headerlink" title="CSS实现元素水平垂直居中"></a>CSS实现元素水平垂直居中</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>已知元素宽高<ul><li>父元素相对定位</li><li>absolute + 负margin</li><li>absolute + margin auto</li><li>absolute + calc（50% - 1&#x2F;2 width | height）</li></ul></li><li>未知元素宽高<ol><li>父元素Flex justify-content align-items</li><li>父元素Grid 子元素 justify-self align-self</li><li>Absolute transform:translate(-50%,-50%)</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 居中 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Position详解</title>
      <link href="/2023/06/24/css-20230624/"/>
      <url>/2023/06/24/css-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="细说Position"><a href="#细说Position" class="headerlink" title="细说Position"></a>细说Position</h1><p>Position总共有五个取值，分别为static默认定位，absolute绝对定位，relative相对定位，fixed固定定位和sticky粘性定位。</p><h2 id="Static默认定位"><a href="#Static默认定位" class="headerlink" title="Static默认定位"></a>Static默认定位</h2><p>该元素使用正常布局，此时 top、right、bottom、left 属性无效。</p><h2 id="Absolute绝对定位"><a href="#Absolute绝对定位" class="headerlink" title="Absolute绝对定位"></a>Absolute绝对定位</h2><p>绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于html</p><p>absolute 定位使元素的位置与文档流无关，因此不占据空间。<em><strong>绝对定位后会脱离文档流</strong></em></p><p>absolute 定位的元素和其他元素重叠。</p><h2 id="Relative相对定位"><a href="#Relative相对定位" class="headerlink" title="Relative相对定位"></a>Relative相对定位</h2><p>relative 相对定位元素的定位是相对其正常位置。就是相对于原来的位置进行定位</p><p>设置relative属性但不设置top left right</p><h2 id="Fixed固定定位"><a href="#Fixed固定定位" class="headerlink" title="Fixed固定定位"></a>Fixed固定定位</h2><p>元素的位置相对于浏览器窗口是固定位置。</p><p>即使窗口是滚动的它也不会移动。</p><p>Fixed定位使元素的位置与文档流无关，因此不占据空间。</p><p>Fixed定位的元素和其他元素重叠。</p><h2 id="Sticky粘性定位"><a href="#Sticky粘性定位" class="headerlink" title="Sticky粘性定位"></a>Sticky粘性定位</h2><p>包含了 relative 与 fixed 这两种定位模式，但不是同时存在，需要一个触发条件，即边偏移 top &#x2F; right &#x2F; bottom &#x2F; left 的值达到后就会切换 fixed 方式，不同定位方式，就分别显示该方式的定位特征。</p><p>举例子就是广告。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> Position属性 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/2023/06/24/js-20230624/"/>
      <url>/2023/06/24/js-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器中的事件循环（EventLoop）"><a href="#浏览器中的事件循环（EventLoop）" class="headerlink" title="浏览器中的事件循环（EventLoop）"></a>浏览器中的事件循环（EventLoop）</h1><h2 id="微任务与宏任务"><a href="#微任务与宏任务" class="headerlink" title="微任务与宏任务"></a>微任务与宏任务</h2><p>JS是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以<strong>微任务队列要优先于宏任务队列</strong>。</p><p>微任务，是语言提供的，Promise.then，MutationObserver</p><p>宏任务，是宿主环境提供的，比如浏览器，script主代码块，setImmediate setTimeout，setInterval</p><p>事件循环可以简单的描述为以下四个步骤:</p><ol><li>函数入栈，当Stack中执行到异步任务的时候，就将他丢给WebAPIs,接着执行同步任务,直到Stack为空；</li><li>此期间WebAPIs完成这个事件，把回调函数放入队列中等待执行（微任务放到微任务队列，宏任务放到宏任务队列）</li><li>执行栈为空时，Event Loop把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取队列的第一项任务放入Stack(栈）中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此反复循环，直至清空所有的任务。</li></ol><p>同步代码，微任务异步代码，宏任务异步代码。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 事件循环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端跨域问题</title>
      <link href="/2023/06/24/web-20230624/"/>
      <url>/2023/06/24/web-20230624/</url>
      
        <content type="html"><![CDATA[<h1 id="聊聊跨域问题"><a href="#聊聊跨域问题" class="headerlink" title="聊聊跨域问题"></a>聊聊跨域问题</h1><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>跨域问题的产生源于浏览器的同源策略，浏览器要求网页只能够获取与自身来源同源的资源。同源代表着协议，域名与端口均要相同</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>跨域问题会导致以下三个问题：</p><ol><li>Cookie、LocalStorage 和 IndexDB 无法读取 </li><li>DOM 和 Js对象无法获得</li><li>AJAX 请求不能发送</li></ol><h2 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h2><ol><li><p>JSONP(JSON with Padding) 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数，并在script标签内设置一个回调执行函数</p><p>但是缺点明显：只能实现get一种请求。</p><p>服务端要设置Content-Type为application&#x2F;json，并获取callback参数值</p></li><li><p>跨域资源共享（CORS）</p><ul><li>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。Access-Control-Allow-Credentials，允许前端带认证cookie：启用此项后，上面的域名不能为’*’，必须指定具体的域名，否则浏览器会提示</li></ul></li><li><p>nginx代理跨域</p></li></ol><p><strong>nginx反向代理接口跨域</strong></p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p><p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p><p>nginx具体配置：</p><pre><code class="nginx">#proxy服务器server &#123;    listen       81;    server_name  www.domain1.com;    location / &#123;        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nginx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js_20230623</title>
      <link href="/2023/06/23/js-20230623/"/>
      <url>/2023/06/23/js-20230623/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-栈与堆、浅拷贝与深拷贝"><a href="#JS-栈与堆、浅拷贝与深拷贝" class="headerlink" title="JS 栈与堆、浅拷贝与深拷贝"></a>JS 栈与堆、浅拷贝与深拷贝</h1><h2 id="栈内存与堆内存"><a href="#栈内存与堆内存" class="headerlink" title="栈内存与堆内存"></a>栈内存与堆内存</h2><p><strong>栈内存</strong>：JS中的基础数据类型（固定大小）存放于栈内存中（Number，String，Boolean，Null，Undefined），访问时是按值访问。</p><p><strong>堆内存</strong>：JS中的引用数据类型（大小不固定）存放于堆内存中（Array，Object），访问时是按引用访问。访问保存在栈内存中的一个地址。地址与堆内存中的存储位置对应。变量存在于栈内存中，对象存在于堆内存中。</p><h2 id="内存的生命周期"><a href="#内存的生命周期" class="headerlink" title="内存的生命周期"></a>内存的生命周期</h2><p>JS环境中分配的内存一般有如下生命周期：</p><ol><li>内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存</li><li>内存使用：即读写内存，也就是使用变量、函数等</li><li>内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</li></ol><h2 id="浅拷贝与深拷贝与赋值"><a href="#浅拷贝与深拷贝与赋值" class="headerlink" title="浅拷贝与深拷贝与赋值"></a>浅拷贝与深拷贝与赋值</h2><ol><li>赋值：赋值的是栈中的地址，不是堆中的数据。两个对象是联动的。</li><li>浅拷贝：重新在堆中创建内存，基本数据类型互不影响，引用类型因共享同一块内存，会相互影响。</li><li>深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。</li></ol><p><img src="/../images/js_20230623_1.png" alt="js_20230623_1"></p><p><img src="/../images/js_20230623_2.png" alt="js_20230623_2"></p><h2 id="浅拷贝与深拷贝的实现方式"><a href="#浅拷贝与深拷贝的实现方式" class="headerlink" title="浅拷贝与深拷贝的实现方式"></a>浅拷贝与深拷贝的实现方式</h2><h3 id="浅拷贝："><a href="#浅拷贝：" class="headerlink" title="浅拷贝："></a>浅拷贝：</h3><ol><li>Object.assign()</li><li>lodash的 _.clone方法</li><li>ES6  …展开运算符</li></ol><h3 id="深拷贝："><a href="#深拷贝：" class="headerlink" title="深拷贝："></a>深拷贝：</h3><ol><li><p>JSON.parse(JSON.stringify())</p></li><li><p>lodash 的 _.deepclone方法</p></li><li><p>手写</p><pre><code class="javascript">function deepClone(obj, hash = new WeakMap()) &#123;    if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作    if (obj instanceof Date) return new Date(obj);    if (obj instanceof RegExp) return new RegExp(obj);    // 可能是对象或者普通的值  如果是函数的话是不需要深拷贝    if (typeof obj !== &quot;object&quot;) return obj;    // 是对象的话就要进行深拷贝    if (hash.get(obj)) return hash.get(obj);    let cloneObj = new obj.constructor();    // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身    hash.set(obj, cloneObj);    for (let key in obj) &#123;        if (obj.hasOwnProperty(key)) &#123;          // 实现一个递归拷贝              cloneObj[key] = deepClone(obj[key], hash);        &#125;    &#125;    return cloneObj;&#125;</code></pre></li></ol><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 栈与堆 </tag>
            
            <tag> 深拷贝 </tag>
            
            <tag> 浅拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cybersecurity_20230623</title>
      <link href="/2023/06/23/cybersecurity-20230623/"/>
      <url>/2023/06/23/cybersecurity-20230623/</url>
      
        <content type="html"><![CDATA[<h1 id="常见网络安全问题及解决方案"><a href="#常见网络安全问题及解决方案" class="headerlink" title="常见网络安全问题及解决方案"></a>常见网络安全问题及解决方案</h1><h2 id="XSS攻击（跨站脚本攻击）"><a href="#XSS攻击（跨站脚本攻击）" class="headerlink" title="XSS攻击（跨站脚本攻击）"></a>XSS攻击（跨站脚本攻击）</h2><p>XSS是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全,任何可以输入的地方都有可能引起,包括表单、URL…</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>存储型XSS攻击<ol><li>首先黑客利用站点漏洞将一段恶意 JavaScript 代码<strong>提交到被攻击的网站的数据库中</strong>；</li><li>然后用户向网站请求包含了恶意 JavaScript 脚本的页面；</li><li>当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。</li></ol></li><li>反射型XSS攻击<ol><li><strong>攻击者构造出特殊的 URL</strong>，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol></li><li>基于DOM的XSS攻击<ol><li>攻击者通过某种方式，将恶意脚本代码插入到网页中的某个元素中，比如一个输入框或者链接等。</li><li>受害者浏览器通过解析HTML代码生成文档对象模型（DOM）树，恶意脚本代码被加入到DOM树中。</li><li>当受害者与网页进行交互时，例如点击一个链接、提交表单等操作，浏览器就会执行恶意脚本代码。</li><li>恶意脚本代码可以执行一些攻击者预设好的操作，如窃取cookie信息、更改页面内容、将受害者重定向到恶意网站等。</li></ol></li></ul><h3 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li>现代浏览器支持防御部分XSS攻击，在http设置X-XSS-Protection响应头，1为开启0为关闭，mode&#x3D;block意为如果检测到XSS攻击阻止整个界面</li><li>在Cookie和HTTP头中设置HTTP-Only和secure属性，以免被XSS攻击者获取</li><li>合理使用CSP（Content Security Policy）来限制第三方内容的注入，它分别可以使用HTTP请求、HTML mate表情的形式来开启</li></ol><h2 id="跨站请求伪造（CSRF）"><a href="#跨站请求伪造（CSRF）" class="headerlink" title="跨站请求伪造（CSRF）"></a>跨站请求伪造（CSRF）</h2><p>CSRF 攻击是攻击者利用浏览器在发起请求时自动带上 cookie 的特性，借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。</p><h3 id="攻击流程"><a href="#攻击流程" class="headerlink" title="攻击流程"></a>攻击流程</h3><ol><li>受害者登录 a.com，并保留了登录凭证（Cookie）；</li><li>攻击者引诱受害者访问了 b.com；</li><li>b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx浏览器会默认携带a.com的Cookie；</li><li>a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求；</li><li>a.com以受害者的名义执行了act&#x3D;xx；</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作；</li></ol><h3 id="攻击类型"><a href="#攻击类型" class="headerlink" title="攻击类型"></a>攻击类型</h3><ol><li>ET型：如在页面的某个 img 中发起一个 get 请求</li><li>POST型：通过自动提交表单到恶意网站</li><li>链接型：需要诱导用户点击链接</li></ol><h3 id="防御措施-1"><a href="#防御措施-1" class="headerlink" title="防御措施"></a>防御措施</h3><ol><li><p>Cookie 的 SameSite 属性，对于现代浏览器，在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。</p><ul><li><p>Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。</p></li><li><p>Lax 允许部分第三方请求携带 Cookie</p></li><li><p>None 无论是否跨站都会发送 Cookie</p></li></ul></li><li><p>同源检查，由服务器端验证当前请求的来源站点，HTTP 请求头中的 Referer 和 Origin 属性；</p></li><li><p>页面级别的token，将Token输出到页面中，页面提交的请求携带这个Token，服务器验证Token是否正确；</p></li><li><p>验证码，后端接口加验证码校验，让攻击方无法在用户无感知的情况下正常调用接口</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
            <tag> XSS </tag>
            
            <tag> CRSF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>== 与 ===</title>
      <link href="/2023/06/23/js-20230619/"/>
      <url>/2023/06/23/js-20230619/</url>
      
        <content type="html"><![CDATA[<!-- ---title: date: 2023-06-19 21:20:36tags: JavaScript Basic-Knowledge Interview--- --><h1 id="JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’"><a href="#JavaScript-中的’-x3D-x3D-’-与’-x3D-x3D-x3D-’" class="headerlink" title="JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’"></a>JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>“&#x3D;&#x3D;“叫做相等运算符，”&#x3D;&#x3D;&#x3D;”叫做严格运算符</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li>对于String, number这些基础类型，&#x3D;&#x3D;操作符会先把两边的变量进行类型强制转换成相同的类型再比较是否相等；&#x3D;&#x3D;&#x3D;操作符则不会进行类型转换，而是直接进行比较。</li><li>对于array, object这些高级类型，&#x3D;&#x3D;和 &#x3D;&#x3D;&#x3D;是没有区别的，因为它们比较的是 “指针地址” 。</li><li>对于基础类型和高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;是有区别的；&#x3D;&#x3D;操作符会先把高级类型转换为基础类型之后，进行<strong>值的比较</strong>；&#x3D;&#x3D;&#x3D;操作符则不会进行转换，<strong>类型比较</strong>，如果不同，直接返回false</li></ol><pre><code class="javascript">examle:    66 == &#39;66&#39; // True    66 === &#39;66&#39; // False</code></pre><h3 id="特别注意"><a href="#特别注意" class="headerlink" title="特别注意"></a>特别注意</h3><ol><li>对于特殊值NaN（Not a Number），表示非数字，NaN和任何数（包括它自己）做相等比较，都会返回false，所以判断NaN最好用isNaN()函数</li><li>null和undefined，两者值比较为True（&#x3D;&#x3D;），类型比较为False（&#x3D;&#x3D;&#x3D;）</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 基础知识 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/15/Note_Web&amp;Browser/"/>
      <url>/2023/06/15/Note_Web&amp;Browser/</url>
      
        <content type="html"><![CDATA[<h1 id="网络与浏览器"><a href="#网络与浏览器" class="headerlink" title="网络与浏览器"></a>网络与浏览器</h1><h2 id="1-浏览器在输入网址到显示网页的过程"><a href="#1-浏览器在输入网址到显示网页的过程" class="headerlink" title="1.浏览器在输入网址到显示网页的过程"></a>1.浏览器在输入网址到显示网页的过程</h2><ol><li>用户输入网址：用户在浏览器的地址栏中输入网址，例如：”<a href="http://www.example.com"./">www.example.com"。</a></li><li>DNS解析：浏览器会检查本地缓存中是否有与该网址对应的IP地址，如果没有，则会发送DNS（Domain Name System）请求到本地DNS服务器，以获取网址对应的IP地址。如果本地DNS服务器没有该记录，它会向其他DNS服务器发送请求，直到找到对应的IP地址。</li><li>建立连接：浏览器使用获取到的IP地址，通过TCP&#x2F;IP协议与服务器建立连接。这个过程通常涉及与服务器的三次握手，确保浏览器和服务器之间建立可靠的连接。</li><li>发送HTTP请求：一旦与服务器建立连接，浏览器会发送一个HTTP请求，其中包含了请求的类型（GET、POST等）、网址、以及其他附加信息，例如浏览器的信息、Cookie等。</li><li>服务器处理请求：服务器接收到浏览器发送的请求后，会根据请求的内容进行相应的处理。这可能包括读取请求中的数据、执行相应的代码、查询数据库等。</li><li>服务器发送响应：服务器处理完请求后，会生成一个HTTP响应，其中包含了所请求的网页内容以及其他相关信息。响应中的内容通常是一个HTML文档，但也可能包含其他资源，例如CSS样式表、JavaScript脚本、图像等。</li><li>接收响应：浏览器接收到服务器发送的响应后，会开始处理响应。如果响应中包含了其他资源的引用（例如CSS和JavaScript文件），浏览器会继续发送请求来获取这些资源。</li><li>渲染页面：浏览器使用接收到的HTML文档和其他资源，开始解析和渲染页面。它会解析HTML结构，构建DOM（Document Object Model）树，并根据CSS样式对页面进行布局和渲染。如果页面中包含JavaScript代码，浏览器还会执行这些代码。</li><li>显示页面：最后，浏览器会将渲染好的页面显示给用户。它会将页面的内容呈现在浏览器窗口中，并处理用户与页面的交互，例如点击链接、填写表单等</li></ol><h2 id="2-TCP三次握手"><a href="#2-TCP三次握手" class="headerlink" title="2.TCP三次握手"></a>2.TCP三次握手</h2><p>TCP三次握手是建立TCP连接时使用的一种协议，用于确保客户端和服务器之间建立可靠的连接。以下是TCP三次握手的步骤：</p><ol><li>第一次握手（SYN）：<ul><li>客户端发送一个带有SYN（同步序列编号）标志的TCP包给服务器。</li><li>这表示客户端请求与服务器建立连接，并指定一个初始的序列号（用于数据传输的顺序标记）。</li></ul></li><li>第二次握手（SYN-ACK）：<ul><li>服务器接收到客户端的请求后，会发送一个带有SYN和ACK（确认序列编号）标志的TCP包给客户端，ACK表示确认客户端的SYN，SYN也发送自己的初始序列号。</li><li>这表示服务器同意建立连接，并确认客户端的序列号，并指定自己的初始序列号。</li></ul></li><li>第三次握手（ACK）：<ul><li>客户端接收到服务器的响应后，会发送一个带有ACK标志的TCP包给服务器。</li><li>这表示客户端确认服务器的序列号，并且连接已经建立。</li><li>从此时开始，客户端和服务器可以开始进行数据传输。</li></ul></li></ol><p>通过这个三次握手的过程，客户端和服务器能够确保彼此都收到了对方的请求和确认，并且双方都知道了对方的初始序列号。这种握手过程可以防止连接建立失败或者无效连接的情况发生，并提供了一定的可靠性。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay03</title>
      <link href="/2023/03/06/%E5%89%91%E6%8C%87offerDay03/"/>
      <url>/2023/03/06/%E5%89%91%E6%8C%87offerDay03/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——字符串（简单）"><a href="#剑指offerDay02——字符串（简单）" class="headerlink" title="剑指offerDay02——字符串（简单）"></a>剑指offerDay02——字符串（简单）</h1><h2 id="剑指offer-05-替换空格"><a href="#剑指offer-05-替换空格" class="headerlink" title="剑指offer 05 替换空格"></a>剑指offer 05 替换空格</h2><p><img src="/../images/offer05.png" alt="offer05"></p><p>💡思路：</p><ul><li>新建一个StringBuilder，逐字符复制，遇到空格则用“%20”替代</li><li>原地修改更省内存</li></ul><pre><code class="java">class Solution &#123;    public String replaceSpace(String s) &#123;        StringBuilder res = new StringBuilder();        for(Character c : s.toCharArray())        &#123;            if(c == &#39; &#39;) res.append(&quot;%20&quot;);            else res.append(c);        &#125;        return res.toString();    &#125;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay02</title>
      <link href="/2023/03/04/%E5%89%91%E6%8C%87offerDay02/"/>
      <url>/2023/03/04/%E5%89%91%E6%8C%87offerDay02/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay02——链表（简单）"><a href="#剑指offerDay02——链表（简单）" class="headerlink" title="剑指offerDay02——链表（简单）"></a>剑指offerDay02——链表（简单）</h1><h2 id="剑指offer-06-从尾到头打印链表"><a href="#剑指offer-06-从尾到头打印链表" class="headerlink" title="剑指offer 06 从尾到头打印链表"></a>剑指offer 06 从尾到头打印链表</h2><p><img src="/../images/offer06.png" alt="offer06"></p><p>💡思路：</p><ul><li>递归法，先递归到达链表尾部，再用push(head.val)将节点值添加进数组</li><li>循环法，JS可以用数组的unshift方法来从头插入数据，也可以用push + reverse 操作</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.unshift(head.val)        head = head.next    &#125;    return res&#125;;var reversePrint = function(head) &#123;    let res = []    while (head) &#123;        res.push(head.val)        head = head.next    &#125;    return res.reverse()&#125;;var reversePrint = function (head) &#123;    if(!head) return []    let result = reversePrint(head.next)    result.push(head.val);    return result&#125;;</code></pre><h2 id="剑指offer24-反转链表"><a href="#剑指offer24-反转链表" class="headerlink" title="剑指offer24 反转链表"></a>剑指offer24 反转链表</h2><p><img src="/../images/offer24.png" alt="offer24"></p><p>💡思路：</p><ul><li>JS ES6中的解构语法，可以很好的进行赋值。</li></ul><pre><code class="javascript">/** * Definition for singly-linked list. * function ListNode(val) &#123; *     this.val = val; *     this.next = null; * &#125; *//** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */var reverseList = function(head) &#123;    let [p,c] = [null, head]    while(c)&#123;        [c.next,c,p] = [p,c.next,c]    &#125;    return p&#125;;</code></pre><h2 id="剑指offer35-复杂链表的复制"><a href="#剑指offer35-复杂链表的复制" class="headerlink" title="剑指offer35 复杂链表的复制"></a>剑指offer35 复杂链表的复制</h2><p><img src="/../images/offer35_1.png" alt="offer35_1"></p><p><img src="/../images/offer35_2.png" alt="offer35_2"></p><p>💡思路：</p><ul><li>使用hash Map简历原节点 -&gt; 新节点的映射，先复制普通的val与next指针，后根据Map复制random指针<ol><li>复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</li><li>构建新链表的 next 和 random 指向</li><li>返回新链表的头节点</li></ol></li><li>也可先直接将新节点与旧节点连接至一个列表上，再进行新旧列表的拆分。<ol><li>复制各节点，并构建拼接链表</li><li>构建各新节点的 random 指向</li><li>拆分两链表</li></ol></li></ul><pre><code class="javascript">/** * // Definition for a Node. * function Node(val, next, random) &#123; *    this.val = val; *    this.next = next; *    this.random = random; * &#125;; *//** * @param &#123;Node&#125; head * @return &#123;Node&#125; */var copyRandomList = function(head) &#123;    if(head === null)&#123;        return head    &#125;    let curr = head    let newHead = new Node()    let newCurr = newHead    let map = new Map()    while(curr)&#123;        newCurr.val = curr.val        newCurr.next = curr.next ? new Node() : null                map.set(curr, newCurr)        newCurr = newCurr.next        curr = curr.next    &#125;    newCurr = newHead    while(head)&#123;        newCurr.random = head.random ? map.get(head.random) : null        head = head.next        newCurr = newCurr.next    &#125;    return newHead&#125;;// 拼接+拆分链表，空间复杂度O(1)var copyRandomList = function(head)&#123;    if(!head) return head;    let node = head;    // 复制节点，将新节点放到原节点后面    while(node)&#123;        node.next = new Node(node.val, node.next);        node = node.next.next;    &#125;    node = head;    // 构建新节点的random指向    while(node)&#123;        if(node.random !== null) node.next.random = node.random.next;        node = node.next.next;    &#125;    // 拆分链表    let newNode = head.next, res = newNode;    node = head;    while(node.next &amp;&amp; newNode.next)&#123;        node.next = node.next.next;        newNode.next = newNode.next.next;        node = node.next;        newNode = newNode.next;    &#125;    node.next= null;    // 返回新链表的头结点    return res;&#125;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offerDay01</title>
      <link href="/2023/03/03/%E5%89%91%E6%8C%87offerDay01/"/>
      <url>/2023/03/03/%E5%89%91%E6%8C%87offerDay01/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offerDay01——栈与队列（简单）"><a href="#剑指offerDay01——栈与队列（简单）" class="headerlink" title="剑指offerDay01——栈与队列（简单）"></a>剑指offerDay01——栈与队列（简单）</h1><h2 id="剑指offer-09-用两个栈实现队列"><a href="#剑指offer-09-用两个栈实现队列" class="headerlink" title="剑指offer 09 用两个栈实现队列"></a>剑指offer 09 用两个栈实现队列</h2><p><img src="/../images/offer09.png" alt="offer09"></p><p>💡<strong>思路</strong>：</p><ul><li>两个栈分别作用是<strong>入队栈</strong>、<strong>出队栈</strong></li><li><strong>appendTail</strong>方法直接在入队栈内push</li><li><strong>deleteHead</strong>方法需要检查两个栈的长度，先判断出队栈，再判断入队栈。<ol><li>均为空 -&gt; 队列为空</li><li>出队空，入队不空 -&gt; 先用out.push(in.pop)操作将入队栈的元素放入出队栈（两个栈的特性自然维护队列的特性），再pop出队栈.</li></ol></li></ul><pre><code class="javascript">var CQueue = function() &#123;    this.inStack = [];    this.outStack = [];&#125;;/**  * @param &#123;number&#125; value * @return &#123;void&#125; */CQueue.prototype.appendTail = function(value) &#123;    this.inStack.push(value);&#125;;/** * @return &#123;number&#125; */CQueue.prototype.deleteHead = function() &#123;    if (!this.outStack.length) &#123;        if (!this.inStack.length) &#123;            return -1;        &#125;        this.in2out();    &#125;    return this.outStack.pop();&#125;;CQueue.prototype.in2out = function() &#123;    while (this.inStack.length) &#123;        this.outStack.push(this.inStack.pop());    &#125;&#125;;/** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */</code></pre><h2 id="剑指offer-30-包含min函数的栈"><a href="#剑指offer-30-包含min函数的栈" class="headerlink" title="剑指offer 30 包含min函数的栈"></a>剑指offer 30 包含min函数的栈</h2><p><img src="/../images/offer30.png" alt="offer30"></p><p>💡<strong>思路</strong>：</p><ul><li>设置辅助栈，原栈push时，min栈同时保存当前整个栈的min值，即push当前元素和min栈栈顶元素更小的那一个。</li><li>注意开始辅助栈，放入无穷大（Infinity）</li></ul><pre><code class="JavaScript">var MinStack = function() &#123;    this.x_stack = [];    this.min_stack = [Infinity];&#125;;MinStack.prototype.push = function(x) &#123;    this.x_stack.push(x);    this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x));&#125;;MinStack.prototype.pop = function() &#123;    this.x_stack.pop();    this.min_stack.pop();&#125;;MinStack.prototype.top = function() &#123;    return this.x_stack[this.x_stack.length - 1];&#125;;MinStack.prototype.min = function() &#123;    return this.min_stack[this.min_stack.length - 1];&#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇文章</title>
      <link href="/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>你好Hexo<br>你好世界<br><a href="https://craiggeng.github.io/">我的Github个人网站</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/31/hello-world/"/>
      <url>/2022/08/31/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>

{"meta":{"title":"Craig's Blog","subtitle":"","description":"CraigBlog 耿嘉宁的博客","author":"Craig Geng","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Node.js学习笔记","slug":"Note-Nodejs","date":"2023-02-23T05:40:41.000Z","updated":"2023-02-23T05:41:10.170Z","comments":true,"path":"2023/02/23/Note-Nodejs/","link":"","permalink":"http://example.com/2023/02/23/Note-Nodejs/","excerpt":"","text":"Node.js学习笔记1.Node.js安装与使用1.Nodejs 可以使JS在服务器上运行（不仅仅是在浏览器上运行），用于编写服务器 2.Java多线程，一个顾客配一个服务员；Nodejs单线程，多个顾客只有一个服务员。 在服务器端最慢的是服务器和数据库之间的I&#x2F;O。Java中，服务器中的线程更多的时候在等I&#x2F;O 3.Nodejs特点，单线程，异步，非阻塞；统一API（JS语言）4.nvm，用于切换node版本 命令：nvm install latest安装最新版本，nvm install –lts安装稳定版本，nvm ls 列出安装的node 版本，nvm use [别名stable&#x2F;system&#x2F;latest]…… (整理安装步骤) 5.node xxx.js 执行js文件 2.异步进程和线程 进程（厂房） 程序的运行的环境 线程（工人） 线程是实际进行运算的东西 ​ 同步 通常情况代码都是自上向下一行一行执行的 前边的代码不执行后边的代码也不会执行 同步的代码执行会出现阻塞的情况 一行代码执行慢会影响到整个程序的执行 ​ 解决同步问题： java python 通过多线程来解决 node.js 通过异步方式来解决 ​ 异步 一段代码的执行不会影响到其他的程序 异步的问题：异步的代码无法通过return来设置返回值 特点：1.不会阻塞其他代码的执行2.需要通过回调函数来返回结果 基于回调函数的异步带来的问题 代码的可读性差 可调试性差 解决问题： 需要一个东西，可以代替回调函数来给我们返回结果 [ ()&#x3D;&gt;{} ] Promise横空出世 Promise是一个可以用来存储数据的对象Promise存储数据的方式比较特殊，这种特殊方式使得Promise可以用来存储异步调用的数据 举例：现实生活 1.点菜 2.厨师做菜 3.吃 3.Promise 异步调用必须要通过回调函数来返回数据， ​ 当我们进行一些复杂的调用的时，会出现“回调地狱” 问题： ​ 异步必须通过回调函数来返回结果，回调函数一多就很痛苦 创建Promise ​ - Promise可以帮助我们解决异步中的回调函数的问题 ​ - Promise就是一个用来存储数据的容器 ​ 它拥有着一套特殊的存取数据的方式 ​ 这个方式使得它里边可以存储异步调用的结果 const promise = new Promise((resolve, reject) =&gt; &#123; // resolve 和 reject 是两个函数，通过这两个函数可以向Promise中存储数据 // resolve在执行正常时存储数据，reject在执行错误时存储数据 resolve(xxx) reject(xxx) &#125; 从Promise中读取数据 ​ - 可以通过Promise的实例方法then来读取Promise中存储的数据 ​ - then需要两个回调函数作为参数，回调函数用来获取Promise中的数据 ​ 通过resolve存储的数据，会调用第一个函数返回， ​ 可以在第一个函数中编写处理数据的代码 ​ 通过reject存储的数据或者出现异常时，会调用第二个函数返回 ​ 可以在第二个函数中编写处理异常的代码 promise.then( (result) =&gt; &#123; console.log(&quot;1&quot;, result) &#125;, (reason) =&gt; &#123; console.log(&quot;2&quot;, reason) &#125;) Promise中维护了两个隐藏属性： ​ PromiseResult ​ - 用来存储数据（无论resolve传还是reject传） ​ PromiseState ​ - 记录Promise的状态（三种状态） ​ pending （进行中） ​ fulfilled（完成） 通过resolve存储数据时 ​ rejected（拒绝，出错了） 出错了或通过reject存储数据时 ​ - state只能修改一次，修改以后永远不会在变 ​ ​ 流程： ​ 当Promise创建时，PromiseState初始值为pending， ​ 当通过resolve存储数据时 PromiseState 变为fulfilled（完成） ​ PromiseResult变为存储的数据 ​ 当通过reject存储数据或出错时 PromiseState 变为rejected（拒绝，出错了） ​ PromiseResult变为存储的数据 或 异常对象 ​ 当我们通过then读取数据时，相当于为Promise设置了回调函数， ​ 如果PromiseState变为fulfilled，则调用then的第一个回调函数来返回数据 ​ 如果PromiseState变为rejected，则调用then的第二个回调函数来返回数据 ​ 执行顺序 1.js正常代码，2. Promise.then() 3.setTimeout catch() 用法和then类似，但是只需要一个回调函数作为参数 ​ - catch()中的回调函数只会在Promise被拒绝时才调用 ​ - catch() 相当于 then(null, reason &#x3D;&gt; {}) ​ - catch() 就是一个专门处理Promise异常的方法 finally() 通常用来编写一些无论成功与否都要执行代码 ​ - 无论是正常存储数据还是出现异常了，finally总会执行 ​ - 但是finally的回调函数中不会接收到数据 promise中的 ​ then (return new Promise()) ​ catch ​ - 这三个方法都会返回一个新的Promise, ​ Promise中会存储回调函数的返回值 ​ finally ​ - finally的返回值，不会存储到新的Promise中 对于Promise 的链式调用（.then &#x2F; .catch），如果得到的结果不是当前想要的结果，则跳过该调用，进入下一个。 当Promise出现异常时，而整个调用链中没有出现catch，则异常会向外抛出 Promise中的静态方法 ​ Promise.resolve() 创建一个立即完成的Promise ​ Promise.reject() 创建一个立即拒绝的Promise ​ Promise.all([…]) 同时返回多个Promise的执行结果 ​ 其中有一个报错，就返回错误 ​ Promise.allSettled([…]) 同时返回多个Promise的执行结果(无论成功或失败) ​ {status: ‘fulfilled’, value: 579} ​ {status: ‘rejected’, reason: ‘哈哈’} ​ Promise.race([…]) 返回执行最快的Promise（不考虑对错）* ​ Promise.any([…]) 返回执行最快的 且 完成的Promise","categories":[],"tags":[]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2022-08-31T01:45:38.601Z","updated":"2022-09-02T08:31:30.722Z","comments":true,"path":"2022/08/31/我的第一篇文章/","link":"","permalink":"http://example.com/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"你好Hexo你好世界我的Github个人网站","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-31T01:43:54.393Z","updated":"2022-08-31T01:43:54.393Z","comments":true,"path":"2022/08/31/hello-world/","link":"","permalink":"http://example.com/2022/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}
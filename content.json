{"meta":{"title":"Craig's Blog","subtitle":"","description":"CraigBlog 耿嘉宁的博客","author":"Craig Geng","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"Note_BaseKnowledge","slug":"Note-BaseKnowledge","date":"2023-03-16T06:57:15.000Z","updated":"2023-03-16T06:57:15.963Z","comments":true,"path":"2023/03/16/Note-BaseKnowledge/","link":"","permalink":"http://example.com/2023/03/16/Note-BaseKnowledge/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"剑指offerDay03","slug":"剑指offerDay03","date":"2023-03-06T09:47:27.000Z","updated":"2023-03-06T09:56:57.615Z","comments":true,"path":"2023/03/06/剑指offerDay03/","link":"","permalink":"http://example.com/2023/03/06/%E5%89%91%E6%8C%87offerDay03/","excerpt":"","text":"剑指offerDay02——字符串（简单）剑指offer 05 替换空格 💡思路： 新建一个StringBuilder，逐字符复制，遇到空格则用“%20”替代 原地修改更省内存 class Solution &#123; public String replaceSpace(String s) &#123; StringBuilder res = new StringBuilder(); for(Character c : s.toCharArray()) &#123; if(c == &#39; &#39;) res.append(&quot;%20&quot;); else res.append(c); &#125; return res.toString(); &#125; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offerDay02","slug":"剑指offerDay02","date":"2023-03-04T03:30:12.000Z","updated":"2023-03-04T09:00:15.310Z","comments":true,"path":"2023/03/04/剑指offerDay02/","link":"","permalink":"http://example.com/2023/03/04/%E5%89%91%E6%8C%87offerDay02/","excerpt":"","text":"剑指offerDay02——链表（简单）剑指offer 06 从尾到头打印链表 💡思路： 递归法，先递归到达链表尾部，再用push(head.val)将节点值添加进数组 循环法，JS可以用数组的unshift方法来从头插入数据，也可以用push + reverse 操作 /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ /** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */ var reversePrint = function(head) &#123; let res = [] while (head) &#123; res.unshift(head.val) head = head.next &#125; return res &#125;; var reversePrint = function(head) &#123; let res = [] while (head) &#123; res.push(head.val) head = head.next &#125; return res.reverse() &#125;; var reversePrint = function (head) &#123; if(!head) return [] let result = reversePrint(head.next) result.push(head.val); return result &#125;; 剑指offer24 反转链表 💡思路： JS ES6中的解构语法，可以很好的进行赋值。 /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ /** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */ var reverseList = function(head) &#123; let [p,c] = [null, head] while(c)&#123; [c.next,c,p] = [p,c.next,c] &#125; return p &#125;; 剑指offer35 复杂链表的复制 💡思路： 使用hash Map简历原节点 -&gt; 新节点的映射，先复制普通的val与next指针，后根据Map复制random指针 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射 构建新链表的 next 和 random 指向 返回新链表的头节点 也可先直接将新节点与旧节点连接至一个列表上，再进行新旧列表的拆分。 复制各节点，并构建拼接链表 构建各新节点的 random 指向 拆分两链表 /** * // Definition for a Node. * function Node(val, next, random) &#123; * this.val = val; * this.next = next; * this.random = random; * &#125;; */ /** * @param &#123;Node&#125; head * @return &#123;Node&#125; */ var copyRandomList = function(head) &#123; if(head === null)&#123; return head &#125; let curr = head let newHead = new Node() let newCurr = newHead let map = new Map() while(curr)&#123; newCurr.val = curr.val newCurr.next = curr.next ? new Node() : null map.set(curr, newCurr) newCurr = newCurr.next curr = curr.next &#125; newCurr = newHead while(head)&#123; newCurr.random = head.random ? map.get(head.random) : null head = head.next newCurr = newCurr.next &#125; return newHead &#125;; // 拼接+拆分链表，空间复杂度O(1) var copyRandomList = function(head)&#123; if(!head) return head; let node = head; // 复制节点，将新节点放到原节点后面 while(node)&#123; node.next = new Node(node.val, node.next); node = node.next.next; &#125; node = head; // 构建新节点的random指向 while(node)&#123; if(node.random !== null) node.next.random = node.random.next; node = node.next.next; &#125; // 拆分链表 let newNode = head.next, res = newNode; node = head; while(node.next &amp;&amp; newNode.next)&#123; node.next = node.next.next; newNode.next = newNode.next.next; node = node.next; newNode = newNode.next; &#125; node.next= null; // 返回新链表的头结点 return res; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offerDay01","slug":"剑指offerDay01","date":"2023-03-03T03:27:41.000Z","updated":"2023-03-04T06:00:53.605Z","comments":true,"path":"2023/03/03/剑指offerDay01/","link":"","permalink":"http://example.com/2023/03/03/%E5%89%91%E6%8C%87offerDay01/","excerpt":"","text":"剑指offerDay01——栈与队列（简单）剑指offer 09 用两个栈实现队列 💡思路： 两个栈分别作用是入队栈、出队栈 appendTail方法直接在入队栈内push deleteHead方法需要检查两个栈的长度，先判断出队栈，再判断入队栈。 均为空 -&gt; 队列为空 出队空，入队不空 -&gt; 先用out.push(in.pop)操作将入队栈的元素放入出队栈（两个栈的特性自然维护队列的特性），再pop出队栈. var CQueue = function() &#123; this.inStack = []; this.outStack = []; &#125;; /** * @param &#123;number&#125; value * @return &#123;void&#125; */ CQueue.prototype.appendTail = function(value) &#123; this.inStack.push(value); &#125;; /** * @return &#123;number&#125; */ CQueue.prototype.deleteHead = function() &#123; if (!this.outStack.length) &#123; if (!this.inStack.length) &#123; return -1; &#125; this.in2out(); &#125; return this.outStack.pop(); &#125;; CQueue.prototype.in2out = function() &#123; while (this.inStack.length) &#123; this.outStack.push(this.inStack.pop()); &#125; &#125;; /** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */ 剑指offer 30 包含min函数的栈 💡思路： 设置辅助栈，原栈push时，min栈同时保存当前整个栈的min值，即push当前元素和min栈栈顶元素更小的那一个。 注意开始辅助栈，放入无穷大（Infinity） var MinStack = function() &#123; this.x_stack = []; this.min_stack = [Infinity]; &#125;; MinStack.prototype.push = function(x) &#123; this.x_stack.push(x); this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); &#125;; MinStack.prototype.pop = function() &#123; this.x_stack.pop(); this.min_stack.pop(); &#125;; MinStack.prototype.top = function() &#123; return this.x_stack[this.x_stack.length - 1]; &#125;; MinStack.prototype.min = function() &#123; return this.min_stack[this.min_stack.length - 1]; &#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2022-08-31T01:45:38.601Z","updated":"2022-09-02T08:31:30.722Z","comments":true,"path":"2022/08/31/我的第一篇文章/","link":"","permalink":"http://example.com/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"你好Hexo你好世界我的Github个人网站","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-31T01:43:54.393Z","updated":"2022-08-31T01:43:54.393Z","comments":true,"path":"2022/08/31/hello-world/","link":"","permalink":"http://example.com/2022/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]}
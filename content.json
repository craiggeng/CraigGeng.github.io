{"meta":{"title":"Craig's Blog","subtitle":"","description":"CraigBlog 耿嘉宁的博客","author":"Craig Geng","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"js_20230623","slug":"js-20230623","date":"2023-06-23T11:30:50.000Z","updated":"2023-06-23T12:22:00.267Z","comments":true,"path":"2023/06/23/js-20230623/","link":"","permalink":"http://example.com/2023/06/23/js-20230623/","excerpt":"","text":"JS 栈与堆、浅拷贝与深拷贝栈内存与堆内存栈内存：JS中的基础数据类型（固定大小）存放于栈内存中（Number，String，Boolean，Null，Undefined），访问时是按值访问。 堆内存：JS中的引用数据类型（大小不固定）存放于堆内存中（Array，Object），访问时是按引用访问。访问保存在栈内存中的一个地址。地址与堆内存中的存储位置对应。变量存在于栈内存中，对象存在于堆内存中。 内存的生命周期JS环境中分配的内存一般有如下生命周期： 内存分配：当我们申明变量、函数、对象的时候，系统会自动为他们分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存 浅拷贝与深拷贝与赋值 赋值：赋值的是栈中的地址，不是堆中的数据。两个对象是联动的。 浅拷贝：重新在堆中创建内存，基本数据类型互不影响，引用类型因共享同一块内存，会相互影响。 深拷贝：从堆内存中开辟一个新的区域存放新对象，对对象中的子对象进行递归拷贝,拷贝前后的两个对象互不影响。 浅拷贝与深拷贝的实现方式浅拷贝： Object.assign() lodash的 _.clone方法 ES6 …展开运算符 深拷贝： JSON.parse(JSON.stringify()) lodash 的 _.deepclone方法 手写 function deepClone(obj, hash = new WeakMap()) &#123; if (obj === null) return obj; // 如果是null或者undefined我就不进行拷贝操作 if (obj instanceof Date) return new Date(obj); if (obj instanceof RegExp) return new RegExp(obj); // 可能是对象或者普通的值 如果是函数的话是不需要深拷贝 if (typeof obj !== &quot;object&quot;) return obj; // 是对象的话就要进行深拷贝 if (hash.get(obj)) return hash.get(obj); let cloneObj = new obj.constructor(); // 找到的是所属类原型上的constructor,而原型上的 constructor指向的是当前类本身 hash.set(obj, cloneObj); for (let key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; // 实现一个递归拷贝 cloneObj[key] = deepClone(obj[key], hash); &#125; &#125; return cloneObj; &#125;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"栈与堆","slug":"栈与堆","permalink":"http://example.com/tags/%E6%A0%88%E4%B8%8E%E5%A0%86/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://example.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"http://example.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"}]},{"title":"cybersecurity_20230623","slug":"cybersecurity-20230623","date":"2023-06-23T09:09:51.000Z","updated":"2023-06-23T12:41:25.584Z","comments":true,"path":"2023/06/23/cybersecurity-20230623/","link":"","permalink":"http://example.com/2023/06/23/cybersecurity-20230623/","excerpt":"","text":"常见网络安全问题及解决方案XSS攻击（跨站脚本攻击）XSS是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全,任何可以输入的地方都有可能引起,包括表单、URL… 分类 存储型XSS攻击 首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到被攻击的网站的数据库中； 然后用户向网站请求包含了恶意 JavaScript 脚本的页面； 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到服务器。 反射型XSS攻击 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 基于DOM的XSS攻击 攻击者通过某种方式，将恶意脚本代码插入到网页中的某个元素中，比如一个输入框或者链接等。 受害者浏览器通过解析HTML代码生成文档对象模型（DOM）树，恶意脚本代码被加入到DOM树中。 当受害者与网页进行交互时，例如点击一个链接、提交表单等操作，浏览器就会执行恶意脚本代码。 恶意脚本代码可以执行一些攻击者预设好的操作，如窃取cookie信息、更改页面内容、将受害者重定向到恶意网站等。 防御措施 现代浏览器支持防御部分XSS攻击，在http设置X-XSS-Protection响应头，1为开启0为关闭，mode&#x3D;block意为如果检测到XSS攻击阻止整个界面 在Cookie和HTTP头中设置HTTP-Only和secure属性，以免被XSS攻击者获取 合理使用CSP（Content Security Policy）来限制第三方内容的注入，它分别可以使用HTTP请求、HTML mate表情的形式来开启 跨站请求伪造（CSRF）CSRF 攻击是攻击者利用浏览器在发起请求时自动带上 cookie 的特性，借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。 攻击流程 受害者登录 a.com，并保留了登录凭证（Cookie）； 攻击者引诱受害者访问了 b.com； b.com 向 a.com 发送了一个请求：a.com&#x2F;act&#x3D;xx浏览器会默认携带a.com的Cookie； a.com接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求； a.com以受害者的名义执行了act&#x3D;xx； 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让a.com执行了自己定义的操作； 攻击类型 ET型：如在页面的某个 img 中发起一个 get 请求 POST型：通过自动提交表单到恶意网站 链接型：需要诱导用户点击链接 防御措施 Cookie 的 SameSite 属性，对于现代浏览器，在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项。 Strict 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。 Lax 允许部分第三方请求携带 Cookie None 无论是否跨站都会发送 Cookie 同源检查，由服务器端验证当前请求的来源站点，HTTP 请求头中的 Referer 和 Origin 属性； 页面级别的token，将Token输出到页面中，页面提交的请求携带这个Token，服务器验证Token是否正确； 验证码，后端接口加验证码校验，让攻击方无法在用户无感知的情况下正常调用接口","categories":[],"tags":[{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"},{"name":"CRSF","slug":"CRSF","permalink":"http://example.com/tags/CRSF/"}]},{"title":"== 与 ===","slug":"js-20230619","date":"2023-06-23T08:41:33.000Z","updated":"2023-06-23T09:15:20.931Z","comments":true,"path":"2023/06/23/js-20230619/","link":"","permalink":"http://example.com/2023/06/23/js-20230619/","excerpt":"","text":"JavaScript 中的’&#x3D;&#x3D;’ 与’&#x3D;&#x3D;&#x3D;’定义“&#x3D;&#x3D;“叫做相等运算符，”&#x3D;&#x3D;&#x3D;”叫做严格运算符 区别 对于String, number这些基础类型，&#x3D;&#x3D;操作符会先把两边的变量进行类型强制转换成相同的类型再比较是否相等；&#x3D;&#x3D;&#x3D;操作符则不会进行类型转换，而是直接进行比较。 对于array, object这些高级类型，&#x3D;&#x3D;和 &#x3D;&#x3D;&#x3D;是没有区别的，因为它们比较的是 “指针地址” 。 对于基础类型和高级类型，&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;是有区别的；&#x3D;&#x3D;操作符会先把高级类型转换为基础类型之后，进行值的比较；&#x3D;&#x3D;&#x3D;操作符则不会进行转换，类型比较，如果不同，直接返回false examle: 66 == &#39;66&#39; // True 66 === &#39;66&#39; // False 特别注意 对于特殊值NaN（Not a Number），表示非数字，NaN和任何数（包括它自己）做相等比较，都会返回false，所以判断NaN最好用isNaN()函数 null和undefined，两者值比较为True（&#x3D;&#x3D;），类型比较为False（&#x3D;&#x3D;&#x3D;）","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"}]},{"title":"剑指offerDay03","slug":"剑指offerDay03","date":"2023-03-06T09:47:27.000Z","updated":"2023-03-06T09:56:57.615Z","comments":true,"path":"2023/03/06/剑指offerDay03/","link":"","permalink":"http://example.com/2023/03/06/%E5%89%91%E6%8C%87offerDay03/","excerpt":"","text":"剑指offerDay02——字符串（简单）剑指offer 05 替换空格 💡思路： 新建一个StringBuilder，逐字符复制，遇到空格则用“%20”替代 原地修改更省内存 class Solution &#123; public String replaceSpace(String s) &#123; StringBuilder res = new StringBuilder(); for(Character c : s.toCharArray()) &#123; if(c == &#39; &#39;) res.append(&quot;%20&quot;); else res.append(c); &#125; return res.toString(); &#125; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offerDay02","slug":"剑指offerDay02","date":"2023-03-04T03:30:12.000Z","updated":"2023-03-04T09:00:15.310Z","comments":true,"path":"2023/03/04/剑指offerDay02/","link":"","permalink":"http://example.com/2023/03/04/%E5%89%91%E6%8C%87offerDay02/","excerpt":"","text":"剑指offerDay02——链表（简单）剑指offer 06 从尾到头打印链表 💡思路： 递归法，先递归到达链表尾部，再用push(head.val)将节点值添加进数组 循环法，JS可以用数组的unshift方法来从头插入数据，也可以用push + reverse 操作 /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ /** * @param &#123;ListNode&#125; head * @return &#123;number[]&#125; */ var reversePrint = function(head) &#123; let res = [] while (head) &#123; res.unshift(head.val) head = head.next &#125; return res &#125;; var reversePrint = function(head) &#123; let res = [] while (head) &#123; res.push(head.val) head = head.next &#125; return res.reverse() &#125;; var reversePrint = function (head) &#123; if(!head) return [] let result = reversePrint(head.next) result.push(head.val); return result &#125;; 剑指offer24 反转链表 💡思路： JS ES6中的解构语法，可以很好的进行赋值。 /** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; */ /** * @param &#123;ListNode&#125; head * @return &#123;ListNode&#125; */ var reverseList = function(head) &#123; let [p,c] = [null, head] while(c)&#123; [c.next,c,p] = [p,c.next,c] &#125; return p &#125;; 剑指offer35 复杂链表的复制 💡思路： 使用hash Map简历原节点 -&gt; 新节点的映射，先复制普通的val与next指针，后根据Map复制random指针 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射 构建新链表的 next 和 random 指向 返回新链表的头节点 也可先直接将新节点与旧节点连接至一个列表上，再进行新旧列表的拆分。 复制各节点，并构建拼接链表 构建各新节点的 random 指向 拆分两链表 /** * // Definition for a Node. * function Node(val, next, random) &#123; * this.val = val; * this.next = next; * this.random = random; * &#125;; */ /** * @param &#123;Node&#125; head * @return &#123;Node&#125; */ var copyRandomList = function(head) &#123; if(head === null)&#123; return head &#125; let curr = head let newHead = new Node() let newCurr = newHead let map = new Map() while(curr)&#123; newCurr.val = curr.val newCurr.next = curr.next ? new Node() : null map.set(curr, newCurr) newCurr = newCurr.next curr = curr.next &#125; newCurr = newHead while(head)&#123; newCurr.random = head.random ? map.get(head.random) : null head = head.next newCurr = newCurr.next &#125; return newHead &#125;; // 拼接+拆分链表，空间复杂度O(1) var copyRandomList = function(head)&#123; if(!head) return head; let node = head; // 复制节点，将新节点放到原节点后面 while(node)&#123; node.next = new Node(node.val, node.next); node = node.next.next; &#125; node = head; // 构建新节点的random指向 while(node)&#123; if(node.random !== null) node.next.random = node.random.next; node = node.next.next; &#125; // 拆分链表 let newNode = head.next, res = newNode; node = head; while(node.next &amp;&amp; newNode.next)&#123; node.next = node.next.next; newNode.next = newNode.next.next; node = node.next; newNode = newNode.next; &#125; node.next= null; // 返回新链表的头结点 return res; &#125;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"剑指offerDay01","slug":"剑指offerDay01","date":"2023-03-03T03:27:41.000Z","updated":"2023-03-04T06:00:53.605Z","comments":true,"path":"2023/03/03/剑指offerDay01/","link":"","permalink":"http://example.com/2023/03/03/%E5%89%91%E6%8C%87offerDay01/","excerpt":"","text":"剑指offerDay01——栈与队列（简单）剑指offer 09 用两个栈实现队列 💡思路： 两个栈分别作用是入队栈、出队栈 appendTail方法直接在入队栈内push deleteHead方法需要检查两个栈的长度，先判断出队栈，再判断入队栈。 均为空 -&gt; 队列为空 出队空，入队不空 -&gt; 先用out.push(in.pop)操作将入队栈的元素放入出队栈（两个栈的特性自然维护队列的特性），再pop出队栈. var CQueue = function() &#123; this.inStack = []; this.outStack = []; &#125;; /** * @param &#123;number&#125; value * @return &#123;void&#125; */ CQueue.prototype.appendTail = function(value) &#123; this.inStack.push(value); &#125;; /** * @return &#123;number&#125; */ CQueue.prototype.deleteHead = function() &#123; if (!this.outStack.length) &#123; if (!this.inStack.length) &#123; return -1; &#125; this.in2out(); &#125; return this.outStack.pop(); &#125;; CQueue.prototype.in2out = function() &#123; while (this.inStack.length) &#123; this.outStack.push(this.inStack.pop()); &#125; &#125;; /** * Your CQueue object will be instantiated and called as such: * var obj = new CQueue() * obj.appendTail(value) * var param_2 = obj.deleteHead() */ 剑指offer 30 包含min函数的栈 💡思路： 设置辅助栈，原栈push时，min栈同时保存当前整个栈的min值，即push当前元素和min栈栈顶元素更小的那一个。 注意开始辅助栈，放入无穷大（Infinity） var MinStack = function() &#123; this.x_stack = []; this.min_stack = [Infinity]; &#125;; MinStack.prototype.push = function(x) &#123; this.x_stack.push(x); this.min_stack.push(Math.min(this.min_stack[this.min_stack.length - 1], x)); &#125;; MinStack.prototype.pop = function() &#123; this.x_stack.pop(); this.min_stack.pop(); &#125;; MinStack.prototype.top = function() &#123; return this.x_stack[this.x_stack.length - 1]; &#125;; MinStack.prototype.min = function() &#123; return this.min_stack[this.min_stack.length - 1]; &#125;;","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]},{"title":"我的第一篇文章","slug":"我的第一篇文章","date":"2022-08-31T01:45:38.601Z","updated":"2022-09-02T08:31:30.722Z","comments":true,"path":"2022/08/31/我的第一篇文章/","link":"","permalink":"http://example.com/2022/08/31/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"","text":"你好Hexo你好世界我的Github个人网站","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-08-31T01:43:54.393Z","updated":"2022-08-31T01:43:54.393Z","comments":true,"path":"2022/08/31/hello-world/","link":"","permalink":"http://example.com/2022/08/31/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://example.com/tags/JavaScript/"},{"name":"栈与堆","slug":"栈与堆","permalink":"http://example.com/tags/%E6%A0%88%E4%B8%8E%E5%A0%86/"},{"name":"深拷贝","slug":"深拷贝","permalink":"http://example.com/tags/%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"http://example.com/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"name":"网络安全","slug":"网络安全","permalink":"http://example.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"XSS","slug":"XSS","permalink":"http://example.com/tags/XSS/"},{"name":"CRSF","slug":"CRSF","permalink":"http://example.com/tags/CRSF/"},{"name":"基础知识","slug":"基础知识","permalink":"http://example.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"面试题","slug":"面试题","permalink":"http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"算法","slug":"算法","permalink":"http://example.com/tags/%E7%AE%97%E6%B3%95/"},{"name":"剑指offer","slug":"剑指offer","permalink":"http://example.com/tags/%E5%89%91%E6%8C%87offer/"}]}